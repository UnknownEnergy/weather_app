<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Temperature, Rainfall, Pollen Contamination & Asthmatic Risk</title>
   <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>☀️</text></svg>">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0 1rem;
      background: #f7f9fc;
      color: #333;
      width: 100vw;
      box-sizing: border-box;
      transition: background 0.3s ease, color 0.3s ease;
    }
    body.dark-mode {
      background: #1a1a1a;
      color: #e0e0e0;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.5rem;
      transition: color 0.3s ease;
    }
    body.dark-mode h1 {
      color: #fff;
    }

    /* NEW Settings menu container and toggle button */
    #settings-menu {
      max-width: 100vw;
      margin: 0 auto 1rem auto;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
    body.dark-mode #settings-menu {
      background: #2d2d2d;
      border-color: #555;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    #settings-menu-header {
      display: flex;
      justify-content: flex-end;
      padding: 0.25rem 0.5rem;
      background: #f0f0f0;
      border-bottom: 1px solid #ddd;
      border-radius: 6px 6px 0 0;
    }
    body.dark-mode #settings-menu-header {
      background: #3a3a3a;
      border-color: #444;
    }
    #settings-toggle-btn {
      font-size: 0.9rem;
      font-weight: bold;
      padding: 0.3rem 0.6rem;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: white;
      transition: background-color 0.2s ease;
    }
    #settings-toggle-btn:hover {
      background-color: #0056b3;
    }
    body.dark-mode #settings-toggle-btn {
      background-color: #4da6ff;
    }
    body.dark-mode #settings-toggle-btn:hover {
      background-color: #3d86cc;
    }

    /* The controls container inside settings */
    #settings-menu-content {
      padding: 1rem;
      display: block;
    }
    #settings-menu.closed #settings-menu-content {
      display: none;
    }

    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 0;
      flex-wrap: wrap;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      white-space: nowrap;
    }
    label {
      font-weight: bold;
      flex-shrink: 0;
      transition: color 0.3s ease;
    }
    body.dark-mode label {
      color: #ddd;
    }
    select, input[type="text"] {
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
      min-width: 140px;
      border-radius: 4px;
      border: 1px solid #ccc;
      flex-shrink: 0;
      background: white;
      color: #333;
      transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    body.dark-mode select, body.dark-mode input[type="text"] {
      background: #2d2d2d;
      color: #e0e0e0;
      border-color: #555;
    }
    #location-btn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: #007bff;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
      align-self: center;
    }
    body.dark-mode #location-btn {
      background-color: #4da6ff;
    }
    #location-btn:hover:not(:disabled) { background-color: #0056b3; }
    body.dark-mode #location-btn:hover:not(:disabled) { background-color: #3d86cc; }
    #location-btn:disabled { background-color: #999; cursor: default; }
    #last-updated-weather, #last-updated-pollen, #info {
      margin-top: 0.5rem;
      font-style: italic;
      color: #555;
      text-align: center;
      font-size: 0.9rem;
      transition: color 0.3s ease;
    }
    body.dark-mode #last-updated-weather, body.dark-mode #last-updated-pollen, body.dark-mode #info {
      color: #aaa;
    }
    #error-msg {
      color: #cc0000;
      font-weight: bold;
      margin-top: 0.5rem;
      text-align: center;
      min-height: 1.2em;
      font-size: 0.95rem;
      transition: color 0.3s ease;
    }
    body.dark-mode #error-msg {
      color: #ff5555;
    }
    #current-temp {
      text-align: center;
      font-weight: bold;
      margin-top: 0.5rem;
      font-size: 1.1rem;
      transition: color 0.3s ease;
    }
    body.dark-mode #current-temp {
      color: #ddd;
    }
    #pollen-select {
      max-height: 150px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 0.5rem;
      font-size: 0.9rem;
      min-width: 200px;
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    body.dark-mode #pollen-select {
      background: #2d2d2d;
      border-color: #555;
    }
    #pollen-select label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    body.dark-mode #pollen-select label {
      color: #e0e0e0;
    }
    canvas {
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      width: 100%;
      margin: 0 auto;
      display: block;
      object-fit: contain;
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
    body.dark-mode canvas {
      background: #2d2d2d;
      border-color: #555;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    @media (max-width: 480px) {
      .controls { gap: 0.75rem; justify-content: center; }
      .control-group { gap: 0.25rem; }
      label, select, input[type="text"], #location-btn { font-size: 1rem; min-width: 110px; padding: 0.4rem 0.5rem; }
      h1 { font-size: 1.3rem; margin-bottom: 1rem; }
      #last-updated-weather, #last-updated-pollen { font-size: 0.85rem; }
      #error-msg { font-size: 0.9rem; }
      #current-temp { font-size: 1rem; }
      #pollen-select { min-width: 150px; max-height: 120px; }
    }
    #dark-mode-toggle {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: #666;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
      align-self: center;
    }
    body.dark-mode #dark-mode-toggle {
      background-color: #888;
    }
    #dark-mode-toggle:hover {
      background-color: #555;
    }
    body.dark-mode #dark-mode-toggle:hover {
      background-color: #999;
    }
     #chart-container {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      margin: 0 auto;
      max-width: 100vw;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      background: white;
      border: 1px solid #ddd;
    }
    #chart-container canvas {
        min-width: 900px;
        height: 400px !important;
        display: block;
        object-fit: contain;
    }
    body.dark-mode #chart-container {
        background: #2d2d2d;
        border-color: #555;
        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    @media (max-width: 500px) {
        #chart-container canvas {
        min-width: 700px;
        }
    }
  </style>
</head>
<body>
  <h1>Temperature, Rainfall, Pollen Contamination & Asthmatic Risk</h1>

  <!-- NEW SETTINGS MENU -->
  <section id="settings-menu" role="region" aria-label="Settings menu">
    <header id="settings-menu-header">
      <button id="settings-toggle-btn" aria-expanded="true" aria-controls="settings-menu-content" aria-label="Toggle settings menu">Hide Settings</button>
    </header>
    <div id="settings-menu-content">
      <div class="controls" role="region" aria-label="Station and time range selection">
        <div class="control-group">
          <label for="station-select">Station:</label>
          <select id="station-select"></select>
        </div>
        <div class="control-group">
          <label for="timerange-select">Past Range:</label>
          <select id="timerange-select" aria-label="Select time range">
            <option value="1">Past 1 hour</option>
            <option value="3">Past 3 hours</option>
            <option value="12" selected>Past 12 hours</option>
            <option value="24">Past 24 hours</option>
            <option value="72">Past 3 days</option>
            <option value="120">Past 5 days</option>
          </select>
        </div>
        <div class="control-group">
          <label for="futuredays-select">Forecast Range:</label>
          <select id="futuredays-select" aria-label="Select forecast days ahead">
            <option value="1">1 hour ahead</option>
            <option value="3">3 hour ahead</option>
            <option value="12" selected>12 hours ahead</option>
            <option value="24">24 hours ahead</option>
            <option value="72">3 days ahead</option>
            <option value="120">5 days ahead</option>
          </select>
        </div>
        <div class="control-group" style="flex-direction: column;">
          <label for="pollen-select" style="font-weight:bold; margin-bottom:0.25rem;">Select Pollens:</label>
          <div id="pollen-select" role="group" aria-label="Select pollens to display contamination"></div>
        </div>
        <div class="control-group">
          <label for="asthma-toggle">Show Asthmatic Risk:</label>
          <input type="checkbox" id="asthma-toggle" aria-label="Toggle Asthmatic Risk chart display">
        </div>
        <div class="control-group">
          <label for="apikey-input">Pollen API Key:</label>
          <input type="text" id="apikey-input" aria-label="Enter Pollen API key" placeholder="Enter Pollen API key" />
        </div>
        <div class="control-group">
          <label for="corsproxy-input">CORS Proxy:</label>
          <input type="text" id="corsproxy-input" aria-label="Enter CORS proxy URL" placeholder="Enter CORS proxy URL">
        </div>
        <button id="location-btn" title="Find nearest station to your current location">Use My Location</button>
        <button id="dark-mode-toggle" title="Toggle dark mode">Dark Mode</button>
      </div>
    </div>
  </section>

  <div id="chart-container">
    <canvas id="tempChart" width="900" height="400" aria-label="Temperature, Rainfall, Pollen Contamination and Asthmatic Risk chart"></canvas>
  </div>
  <div id="current-temp" aria-live="polite" aria-atomic="true"></div>
  <div id="last-updated-weather"></div>
  <div id="last-updated-pollen"></div>
  <div id="info">Data from Geosphere.at, Polleninformation.at, and MenschensWetter.at</div>
  <div id="error-msg" role="alert" aria-live="assertive"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0/dist/chartjs-plugin-annotation.min.js"></script>
  <script>
    Chart.register(window['chartjs-plugin-annotation']);

    // DOM Elements
    const elements = {
      stationSelect: document.getElementById('station-select'),
      locationBtn: document.getElementById('location-btn'),
      errorMsg: document.getElementById('error-msg'),
      ctx: document.getElementById('tempChart').getContext('2d'),
      lastUpdatedWeather: document.getElementById('last-updated-weather'),
      lastUpdatedPollen: document.getElementById('last-updated-pollen'),
      timerangeSelect: document.getElementById('timerange-select'),
      currentTemp: document.getElementById('current-temp'),
      futuredaysSelect: document.getElementById('futuredays-select'),
      corsproxyInput: document.getElementById('corsproxy-input'),
      pollenSelect: document.getElementById('pollen-select'),
      asthmaToggle: document.getElementById('asthma-toggle'),
      darkModeToggle: document.getElementById('dark-mode-toggle'),
      apikeyInput: document.getElementById('apikey-input'),

      // NEW Settings menu elements
      settingsMenu: document.getElementById('settings-menu'),
      settingsToggleBtn: document.getElementById('settings-toggle-btn'),
      settingsMenuContent: document.getElementById('settings-menu-content')
    };

    // State Variables
    let stations = {}, forecastPoints = [], tempChart, refreshIntervalId;
    let pollenData = null, selectedPollens = new Set(), contaminationDates = [];
    let asthmaticRiskData = [], showAsthmaticRisk = false, combinedData = [];
    // German day labels to fetch
    const asthmaDayLabels = ["Vorgestern", "Gestern", "Heute", "Morgen", "Übermorgen"];
    let isDarkMode = false;
    let lastWeatherUpdate = null;
    let lastPollenUpdate = null;

    // Storage Keys
    const STORAGE_KEYS = {
      STATION: 'selectedStationId',
      TIMERANGE: 'selectedTimeRangeHours',
      FUTUREDAYS: 'selectedFutureDays',
      CORSPROXY: 'selectedCorsProxy',
      POLLENS: 'selectedPollens',
      ASTHMA_TOGGLE: 'showAsthmaticRisk',
      DARK_MODE: 'darkMode',
      APIKEY: 'pollenApiKey',
      SETTINGS_MENU_OPEN: 'settingsMenuOpen'  // NEW
    };

    // Default Pollen API key as provided
    const DEFAULT_API_KEY = 'tNzBM7e60cYVqPZWVX5LXPAX7JSGtsRY17y1Xq4uBAaXaVXNYSuzNBqaBDh2PIlq';

    // Utility Functions
    const utils = {
      toISOStringNoMs: date => date.toISOString().split('.')[0] + 'Z',
      capitalizeWords: str => str.toLowerCase().split(/\s+/).map(word => word ? word[0].toUpperCase() + word.slice(1) : '').join(' '),
      haversineDistance: (lat1, lon1, lat2, lon2) => {
        const toRad = angle => angle * Math.PI / 180, R = 6371000;
        const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      },
      applyCorsProxy: url => {
        const proxy = elements.corsproxyInput.value.trim();
        if (!proxy) return url;
        const proxyNormalized = proxy.endsWith('/') ? proxy : proxy + '/';
        return url.startsWith(proxyNormalized) ? url : proxyNormalized + (url.startsWith('/') ? url.slice(1) : url);
      },
      fetchWithProxy: async url => {
        const response = await fetch(utils.applyCorsProxy(url));
        if (!response.ok) throw new Error(`HTTP ${response.status} fetching ${url}`);
        return response.json();
      },
      interpolateTemp: (ts1, temp1, ts2, temp2, targetTs) => {
        const t1 = ts1.getTime(), t2 = ts2.getTime(), t = targetTs.getTime();
        return t2 === t1 ? temp1 : temp1 + ((t - t1) / (t2 - t1)) * (temp2 - temp1);
      },
      randomColorForId: (id, opacity = 1) => {
        const colors = [
          'rgba(255, 99, 132, OPACITY)', 'rgba(54, 162, 235, OPACITY)', 'rgba(255, 206, 86, OPACITY)',
          'rgba(75, 192, 192, OPACITY)', 'rgba(153, 102, 255, OPACITY)', 'rgba(255, 159, 64, OPACITY)',
          'rgba(199, 199, 199, OPACITY)', 'rgba(83, 102, 255, OPACITY)', 'rgba(255, 99, 255, OPACITY)',
          'rgba(99, 255, 132, OPACITY)'
        ];
        return colors[Number(id) % colors.length].replace('OPACITY', opacity);
      }
    };

    // Dark Mode Functions
    const darkMode = {
      init: () => {
        const savedDarkMode = localStorage.getItem(STORAGE_KEYS.DARK_MODE);
        if (savedDarkMode !== null) {
          isDarkMode = savedDarkMode === 'true';
        } else {
          isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        }
        darkMode.applyTheme();
      },
      toggle: () => {
        isDarkMode = !isDarkMode;
        localStorage.setItem(STORAGE_KEYS.DARK_MODE, isDarkMode.toString());
        darkMode.applyTheme();
        if (tempChart) {
          ui.drawChart();
        }
      },
      applyTheme: () => {
        document.body.classList.toggle('dark-mode', isDarkMode);
        elements.darkModeToggle.textContent = isDarkMode ? 'Light Mode' : 'Dark Mode';
      }
    };

    // Settings Menu Functions NEW
    const settingsMenu = {
      init: () => {
        const savedState = localStorage.getItem(STORAGE_KEYS.SETTINGS_MENU_OPEN);
        const open = savedState === null ? true : savedState === 'true';
        settingsMenu.setOpen(open);
        elements.settingsToggleBtn.addEventListener('click', () => {
          settingsMenu.toggle();
        });
      },
      setOpen: (open) => {
        if (open) {
          elements.settingsMenu.classList.remove('closed');
          elements.settingsToggleBtn.textContent = 'Hide Settings';
          elements.settingsToggleBtn.setAttribute('aria-expanded', 'true');
          elements.settingsMenuContent.style.display = 'block';
        } else {
          elements.settingsMenu.classList.add('closed');
          elements.settingsToggleBtn.textContent = 'Show Settings';
          elements.settingsToggleBtn.setAttribute('aria-expanded', 'false');
          elements.settingsMenuContent.style.display = 'none';
        }
        localStorage.setItem(STORAGE_KEYS.SETTINGS_MENU_OPEN, open.toString());
      },
      toggle: () => {
        const isClosed = elements.settingsMenu.classList.contains('closed');
        settingsMenu.setOpen(isClosed);
      }
    };

    // Data Fetching
    const dataFetch = {
      loadForecastPoints: async () => {
        forecastPoints = await utils.fetchWithProxy('https://www.geosphere.at/data/forecasts/points') || [];
      },
      findNearestForecastPoint: (lat, lon) => {
        if (!forecastPoints.length || lat === null || lon === null) return null;
        let minDist = Infinity, nearestPointId = null;
        for (const pt of forecastPoints) {
          const dist = utils.haversineDistance(lat, lon, pt.lat, pt.lon);
          if (dist < minDist) { minDist = dist; nearestPointId = pt.point_id; }
        }
        return nearestPointId;
      },
      fetchFlexiForecast: async (lat, lon) => {
        const pointId = dataFetch.findNearestForecastPoint(lat, lon);
        if (!pointId) return null;
        const data = await utils.fetchWithProxy(`https://www.geosphere.at/data/forecasts/flexi/${pointId}`);
        if (!data.timestamps || !data.features?.length) throw new Error('Invalid forecast data format.');
        const { timestamps, features: [{ properties: { parameters } }] } = data;
        return {
          timestamps: timestamps.map(ts => new Date(ts)),
          t2m: parameters.t2m?.data ?? [],
          rr: parameters.rr?.data ?? []
        };
      },
      fetchPollenDataNewApi: async (lat, lon, apiKey) => {
        if (!lat || !lon) throw new Error('Latitude and longitude required for pollen data.');
        const country = 'AT';
        const lang = 'de';
        const url = `https://www.polleninformation.at/api/forecast/public?country=${country}&lang=${lang}&latitude=${lat}&longitude=${lon}&apikey=${encodeURIComponent(apiKey)}`;
        const data = await utils.fetchWithProxy(url);
        if (!data || !data.contamination) throw new Error('Invalid pollen contamination data from new API');
        return data;
      },
      fetchStationData: async (stationId, hoursRange) => {
        const now = new Date(), startDate = new Date(now.getTime() - hoursRange * 3600 * 1000);
        const url = new URL('https://dataset.api.hub.geosphere.at/v1/station/historical/tawes-v1-10min');
        url.searchParams.set('parameters', 'TL,RR');
        url.searchParams.set('start', utils.toISOStringNoMs(startDate));
        url.searchParams.set('end', utils.toISOStringNoMs(now));
        url.searchParams.set('station_ids', stationId);
        const data = await utils.fetchWithProxy(url.toString());
        if (!data.features?.length) throw new Error('No data available for this station.');
        return data;
      },
      // New function to fetch asthmatic risk from MenschensWetter API
      fetchAsthmaticRisk: async (city, dayLabel, climaticZoneId) => {
  if (!city || !dayLabel) throw new Error('City and day label are required for asthmatic risk');

  const url = `https://www.menschenswetter.at/forecast/public/motivation/${encodeURIComponent(city)}/${encodeURIComponent(dayLabel)}`;
  const headers = {
    'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
  };

  // Apply your CORS proxy if needed - replace utils.applyCorsProxy with your own implementation if different
  const proxiedUrl = utils.applyCorsProxy ? utils.applyCorsProxy(url) : url;

  const response = await fetch(proxiedUrl, { headers });
  if (!response.ok) throw new Error(`HTTP ${response.status} fetching MenschensWetter asthmatic risk`);

  const text = await response.text();

  // Extract JSON string from mwForecastMap.update(...)
  function extractMwForecastMapUpdateJson(text) {
    const startMarker = 'mwForecastMap.update(';
    const startIdx = text.indexOf(startMarker);
    if (startIdx === -1) throw new Error('mwForecastMap.update() not found');

    let idx = startIdx + startMarker.length;
    let openBraces = 0;
    let inString = false;
    let stringChar = null;
    let escapeNext = false;

    for (; idx < text.length; idx++) {
      const char = text[idx];

      if (inString) {
        if (escapeNext) {
          escapeNext = false;
        } else if (char === '\\') {
          escapeNext = true;
        } else if (char === stringChar) {
          inString = false;
          stringChar = null;
        }
      } else {
        if (char === '"' || char === "'") {
          inString = true;
          stringChar = char;
        } else if (char === '{') {
          openBraces++;
        } else if (char === '}') {
          openBraces--;
          if (openBraces === 0) {
            return text.substring(startIdx + startMarker.length, idx + 1);
          }
        }
      }
    }
    throw new Error('Could not find end of mwForecastMap.update JSON');
  }

  let jsonStr;
  try {
    jsonStr = extractMwForecastMapUpdateJson(text);
  } catch (err) {
    throw new Error('Malformed asthmatic risk data JSON: ' + err.message);
  }

  let dataObj;
  try {
    dataObj = JSON.parse(jsonStr);
  } catch (e) {
    throw new Error('Failed to parse asthmatic risk JSON data: ' + e.message);
  }

  // Helper: find climatic_zone_id for city
  function getClimaticZoneIdForCity(config, cityName) {
    if (config.active_residence?.residence?.city?.toLowerCase() === cityName.toLowerCase()) {
      return config.active_residence.residence.climatic_zone_id;
    }
    const cityObj = config.cities.find(c =>
      c.residence.city.toLowerCase() === cityName.toLowerCase()
    );
    return cityObj ? cityObj.residence.climatic_zone_id : null;
  }

  // Extract asthma influence value for a climatic zone and day
  function extractAsthmaValueFromZone(zone, day) {
    if (!zone.forecasts || !zone.forecasts.length) return null;
    // Try to find forecast matching the day exactly
    const forecast = zone.forecasts.find(f => f.day === day) || zone.forecasts[0];
    if (!forecast || !forecast.weather || !forecast.weather.influences) return null;
    const asthmaInfluence = forecast.weather.influences.find(inf => inf.indication && inf.indication.id === 56805278);
    return asthmaInfluence ? asthmaInfluence.value : null;
  }

  if (!dataObj.config) throw new Error('Missing config in forecast data');

  const climaticZoneIdd = getClimaticZoneIdForCity(dataObj.config, city);
  if (!climaticZoneIdd) throw new Error(`Climatic zone not found for city "${city}"`);

  const matchedZone = dataObj.climatic_zones.find(cz => cz.climatic_zone.id === climaticZoneIdd);
  if (!matchedZone) return null;

  return extractAsthmaValueFromZone(matchedZone.climatic_zone, dayLabel);
}

    };

    // UI Updates
    const ui = {
      buildPollenCheckboxes: contamination => {
        elements.pollenSelect.innerHTML = '';
        contamination.forEach(p => {
          const id = `pollen-checkbox-${p.poll_id}`, checked = selectedPollens.has(String(p.poll_id));
          const label = document.createElement('label');
          label.htmlFor = id;
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = id;
          checkbox.value = p.poll_id;
          checkbox.checked = checked;
          checkbox.setAttribute('aria-label', `Toggle contamination for ${p.poll_title}`);
          label.append(checkbox, Object.assign(document.createElement('span'), { textContent: p.poll_title }));
          elements.pollenSelect.appendChild(label);
          checkbox.addEventListener('change', () => {
            checkbox.checked ? selectedPollens.add(checkbox.value) : selectedPollens.delete(checkbox.value);
            localStorage.setItem(STORAGE_KEYS.POLLENS, JSON.stringify([...selectedPollens]));
            if (pollenData) ui.drawChart();
          });
        });
      },
      updateCurrentTemp: data => {
        const latest = data.length ? data[data.length - 1] : null;
        elements.currentTemp.textContent = latest
          ? `Latest (at ${latest.ts.toLocaleTimeString([], { hour12: false, hour: '2-digit' })}): Temperature: ${latest.temp} °C, Rainfall: ${latest.rr.toFixed(2)} mm`
          : 'No recent data available.';
      },
      drawChart: () => {
        if (tempChart) tempChart.destroy();
        if (!combinedData.length) return;
        const startDate = new Date(combinedData[0].ts), endDate = new Date(combinedData[combinedData.length - 1].ts);
        const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const labels = combinedData.map(d => d.ts.toLocaleString([], { hour12: false, hour: '2-digit', minute: '2-digit' }));
        const today = new Date(); today.setHours(0, 0, 0, 0);

        const mapDailyToHourly = (dailyData, numDays) => combinedData.map(({ ts }) => {
            const currentDate = new Date(ts); currentDate.setHours(0, 0, 0, 0);
            const dayIndex = Math.floor((currentDate - today) / (1000 * 60 * 60 * 24));
            return dayIndex >= 0 && dayIndex < numDays && dailyData[dayIndex] !== undefined ? dailyData[dayIndex] : null;
        });

        // Helper functions for color based on value
        const getTempColor = (v) => {
            if (v === null || v === undefined) return isDarkMode ? 'rgba(255, 99, 132, 0.9)' : 'rgba(255, 99, 132, 0.9)';
            if (v < 20) return 'blue';
            if (v >= 20 && v <= 25) return 'green';
            if (v > 25 && v <= 30) return 'orange';
            return 'red';
        };

        const getAsthmaColor = (v) => {
          // Map -3..3 (worst to best) to colors from red to green, with neutral at 0
          switch (v) {
            case -3: return 'rgba(255,0,0,0.9)';         // worst - red
            case -2: return 'rgba(255,69,0,0.85)';       // darker orange-red
            case -1: return 'rgba(255,140,0,0.8)';       // dark orange
            case 0:  return 'rgba(255, 215, 0,0.7)';     // gold/yellow
            case 1:  return 'rgba(144,238,144,0.7)';     // light green
            case 2:  return 'rgba(0,128,0,0.8)';         // green
            case 3:  return 'rgba(0,100,0,0.9)';         // dark green - best
            default: return isDarkMode ? 'rgba(0, 102, 204, 0.9)' : 'rgba(0, 102, 204, 0.9)';
          }
        };

        const getPollenColor = (v) => {
            switch (v) {
            case 1: return 'green';
            case 2: return 'yellow';
            case 3: return 'orange';
            case 4: return 'red';
            default: return isDarkMode ? 'rgba(83, 102, 255, 0.9)' : 'rgba(83, 102, 255, 0.9)';
            }
        };

        // Temperature dataset with color per point
        const tempBorderColors = combinedData.map(d => getTempColor(d.temp));
        const tempPointBgColors = combinedData.map(d => getTempColor(d.temp));
        const tempBgColors = combinedData.map(d => {
            const c = getTempColor(d.temp);
            if (c === 'green') return 'rgba(0,128,0,0.15)';
            if (c === 'blue') return 'rgba(0,0,255,0.15)';
            if (c === 'orange') return 'rgba(255,165,0,0.15)';
            if (c === 'red') return 'rgba(255,0,0,0.15)';
            return 'rgba(255, 99, 132, 0.15)';
        });

        // Pollen contamination datasets with colors per value
        const contaminationDatasets = pollenData?.contamination?.filter(p => selectedPollens.has(String(p.poll_id))).map(p => {
            const data = mapDailyToHourly([
              p.contamination_1 ?? 0,
              p.contamination_2 ?? 0,
              p.contamination_3 ?? 0,
              p.contamination_4 ?? 0
            ], 4);
            const borderColors = data.map(v => getPollenColor(v));
            const bgColors = data.map(v => {
              const c = getPollenColor(v);
              if (c === 'green') return 'rgba(0,128,0,0.2)';
              if (c === 'yellow') return 'rgba(255,255,0,0.2)';
              if (c === 'orange') return 'rgba(255,165,0,0.2)';
              if (c === 'red') return 'rgba(255,0,0,0.2)';
              return 'rgba(83, 102, 255, 0.2)';
            });
            return {
              label: p.poll_title,
              data,
              backgroundColor: bgColors,
              borderColor: borderColors,
              type: 'line',
              fill: true,
              tension: 0.4,
              pointRadius: 3,
              pointHoverRadius: 5,
              pointBackgroundColor: borderColors,
              pointBorderColor: borderColors,
              pointBorderWidth: 1,
              borderWidth: 2,
              yAxisID: 'yPollen',
              spanGaps: true,
              order: 3
            };
        }) || [];

        // Asthmatic Risk dataset with color per value
        let asthmaData = [];
        let asthmaBorderColors = [];
        let asthmaBgColors = [];
        if (showAsthmaticRisk) {
          asthmaData = combinedData.map(({ ts }) => {
            // Find risk for this timestamp by matching date string to the cached risk data
            // asthmaticRiskData is array of { ts: Date, value: int }
            // Find closest or exact match by date (day only)
            const dayOnly = new Date(ts.getFullYear(), ts.getMonth(), ts.getDate()).getTime();
            const found = asthmaticRiskData.find(d => {
              const dDay = new Date(d.ts.getFullYear(), d.ts.getMonth(), d.ts.getDate()).getTime();
              return dDay === dayOnly;
            });
            return found ? found.value : null;
          });
          asthmaBorderColors = asthmaData.map(v => getAsthmaColor(v));
          asthmaBgColors = asthmaData.map(v => {
            const c = getAsthmaColor(v);
            if (c.startsWith('rgba(')) {
              // make 50% opacity for background
              return c.replace(/rgba\(([^,]+),([^,]+),([^,]+),[^)]+\)/, 'rgba($1,$2,$3,0.5)');
            }
            return c;
          });
        }

        const datasets = [
            {
            label: `Mean Temp (°C)`,
            data: combinedData.map(d => d.temp),
            borderColor: tempPointBgColors,
            backgroundColor: tempBgColors,
            fill: true,
            tension: 0.4,
            pointRadius: 3,
            pointHoverRadius: 5,
            pointBackgroundColor: tempPointBgColors,
            pointBorderColor: tempBorderColors,
            pointBorderWidth: 1,
            borderWidth: 2.5,
            yAxisID: 'yTemp',
            spanGaps: true,
            order: 2
            },
            {
            label: `Rainfall (mm)`,
            data: combinedData.map(d => d.rr),
            type: 'bar',
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 0.9)',
            borderWidth: 1.5,
            hoverBackgroundColor: 'rgba(54, 162, 235, 0.8)',
            hoverBorderWidth: 2,
            hoverBorderColor: 'rgba(54, 162, 235, 1)',
            barPercentage: 0.8,
            categoryPercentage: 0.9,
            yAxisID: 'yRain',
            spanGaps: true,
            order: 1
            },
            ...contaminationDatasets
        ];

        if (showAsthmaticRisk) {
          datasets.push({
            label: 'Asthmatic Risk',
            data: asthmaData,
            borderColor: asthmaBorderColors,
            backgroundColor: asthmaBgColors,
            yAxisID: 'yAsthma',
            type: 'line',
            fill: false,
            tension: 0.4,
            pointRadius: 6,
            pointHoverRadius: 8,
            pointBackgroundColor: asthmaBorderColors,
            pointBorderColor: asthmaBorderColors,
            pointBorderWidth: 1.5,
            borderWidth: 2.5,
            spanGaps: true,
            order: 2
          });
        }

        const now = new Date(), annotations = {};
        let nowX = null, nowTemp = null;
        if (combinedData.length === 1 && Math.abs(combinedData[0].ts.getTime() - now.getTime()) <= 30 * 60 * 1000) {
          nowX = 0; nowTemp = combinedData[0].temp;
        } else if (combinedData.length > 1) {
          for (let i = 0; i < combinedData.length - 1; i++) {
            const t0 = combinedData[i].ts.getTime(), t1 = combinedData[i + 1].ts.getTime();
            if (now.getTime() >= t0 && now.getTime() <= t1) {
              nowX = i + (now.getTime() - t0) / (t1 - t0);
              nowTemp = utils.interpolateTemp(combinedData[i].ts, combinedData[i].temp, combinedData[i + 1].ts, combinedData[i + 1].temp, now);
              break;
            }
          }
          if (nowX === null) {
            nowX = now.getTime() < combinedData[0].ts.getTime() ? 0 : combinedData.length - 1;
            nowTemp = combinedData[nowX].temp;
          }
        }

        combinedData.forEach(({ ts }, i) => {
          if (ts.getHours() === 0 && ts.getMinutes() === 0 && i > 0) {
            annotations['midnightLine' + i] = {
              type: 'line', xMin: i, xMax: i, borderColor: isDarkMode ? 'rgba(150, 150, 150, 0.3)' : 'rgba(100, 100, 100, 0.3)',
              borderWidth: 1.5, borderDash: [5, 5], label: {
                content: ts.toLocaleDateString(undefined, { weekday: 'short', day: 'numeric', month: 'short' }),
                enabled: true, position: 'top', backgroundColor: isDarkMode ? 'rgba(80, 80, 80, 0.7)' : 'rgba(50, 50, 50, 0.7)', color: '#fff',
                font: { size: 10, weight: 'bold' }, yAdjust: 0, padding: 4
              }
            };
          }
        });

        if (nowX !== null && nowTemp !== null) {
          annotations['nowLine'] = {
            type: 'line', xMin: nowX, xMax: nowX, borderColor: 'rgba(220, 53, 69, 0.8)', borderWidth: 2,
            borderDash: [6, 4], label: {
              content: `Now: ${nowTemp.toFixed(1)} °C`, enabled: true, position: 'top',
              backgroundColor: 'rgba(220, 53, 69, 0.9)', color: 'white', font: { weight: 'bold', size: 11 },
              yAdjust: 0, xAdjust: 0, padding: 6
            }
          };
        }

        tempChart = new Chart(elements.ctx, {
          type: 'line',
          data: { labels, datasets },
          options: {
            responsive: true,
            animation: { duration: 1000, easing: 'easeInOutQuad' },
            maintainAspectRatio: false,
            layout: { padding: { left: 10, right: 10, top: 10, bottom: 10 } },
            scales: {
              x: { title: { display: true, text: `Time (Hours over ${daysDiff} Day${daysDiff > 1 ? 's' : ''})`, font: { size: 14, weight: 'bold' }, color: isDarkMode ? '#eee' : '#333' }, ticks: { maxRotation: 45, minRotation: 30, autoSkip: true, maxTicksLimit: 24 * daysDiff, font: { size: 11 }, color: isDarkMode ? '#ccc' : '#555' }, grid: { drawOnChartArea: false, color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }, type: 'category' },
              yTemp: { position: 'left', title: { display: true, text: 'Temperature (°C)', font: { size: 14, weight: 'bold' }, color: isDarkMode ? '#eee' : '#333' }, suggestedMin: 0, suggestedMax: 40, grid: { drawOnChartArea: true, color: isDarkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)', lineWidth: 1 }, ticks: { stepSize: 5, font: { size: 11 }, color: isDarkMode ? '#ccc' : '#555' } },
              yRain: { position: 'right', title: { display: true, text: 'Rainfall (mm)', font: { size: 14, weight: 'bold' }, color: isDarkMode ? '#eee' : '#333' }, grid: { drawOnChartArea: false, color: isDarkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)' }, min: 0, max: 15, ticks: { stepSize: 3, font: { size: 11 }, color: isDarkMode ? '#ccc' : '#555' } },
              yPollen: { position: 'right', offset: true, title: { display: true, text: 'Pollen Contamination (0-4)', font: { size: 14, weight: 'bold' }, color: isDarkMode ? '#eee' : '#333' }, grid: { drawOnChartArea: false, color: isDarkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)' }, min: 0, max: 4, ticks: { stepSize: 1, font: { size: 11 }, color: isDarkMode ? '#ccc' : '#555' }, type: 'linear' },
              yAsthma: { position: 'left', offset: true, title: { display: showAsthmaticRisk, text: 'Asthmatic Risk (-3 to 3)', font: { size: 14, weight: 'bold' }, color: isDarkMode ? '#eee' : '#333' }, grid: { drawOnChartArea: false, color: isDarkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)' }, min: -3, max: 3, ticks: { stepSize: 1, font: { size: 11 }, color: isDarkMode ? '#ccc' : '#555' }, type: 'linear', display: showAsthmaticRisk }
            },
            plugins: {
              legend: { display: true, position: 'top', align: 'center', maxHeight: 30, labels: { font: { size: 12 }, color: isDarkMode ? '#eee' : '#333', padding: 15, boxWidth: 20, usePointStyle: true } },
              tooltip: { mode: 'index', intersect: false, position: 'nearest', backgroundColor: isDarkMode ? 'rgba(50, 50, 50, 0.95)' : 'rgba(255, 255, 255, 0.95)', titleColor: isDarkMode ? '#fff' : '#333', bodyColor: isDarkMode ? '#fff' : '#333', titleFont: { size: 13, weight: 'bold' }, bodyFont: { size: 12 }, padding: 10, boxPadding: 5, borderColor: isDarkMode ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)', borderWidth: 1, callbacks: { label: ctx => {
                const label = ctx.dataset.label.split(' - ')[0];
                let unit = '';
                if (label.includes('Temp')) unit = ' °C';
                else if (label.includes('Rainfall')) unit = ' mm';
                else if (label.includes('Asthmatic Risk')) unit = '';
                else if (label.includes('Pollen')) unit = '';
                return `${label}: ${ctx.parsed.y}${unit}`;
              } } },
              annotation: { annotations },
              datalabels: { display: false }
            },
            interaction: { mode: 'nearest', intersect: false, hover: { mode: 'index' } }
          }
        });
      }
    };

    // Core Logic
    const core = {
      loadStations: async () => {
        elements.errorMsg.textContent = '';
        const savedCorsProxy = localStorage.getItem(STORAGE_KEYS.CORSPROXY);
        elements.corsproxyInput.value = savedCorsProxy?.trim() || 'https://cors-anywhere-agfr.onrender.com/';
        try {
          await dataFetch.loadForecastPoints();
          const metaData = await utils.fetchWithProxy('https://www.geosphere.at/data/stations/tawes/points');
          const coordData = await utils.fetchWithProxy('https://www.geosphere.at/data/stations/tawes/current_data');
          if (!metaData.mapping || !coordData.features) throw new Error('Invalid station data format');
          const coordsMap = Object.fromEntries(
            coordData.features.map(f => [String(f.properties.station), { lat: f.geometry.coordinates[1], lon: f.geometry.coordinates[0] }])
          );
          stations = Object.fromEntries(Object.entries(metaData.mapping).map(([id, info]) => [id, {
            name: info.name, klima_id: info.klima_id, elevation: info.elevation,
            lat: coordsMap[id]?.lat ?? null, lon: coordsMap[id]?.lon ?? null, point_id: info.klima_id || id,
            zip: info.zip ?? null,
            climatic_zone_id: info.climatic_zone_id ?? null
          }]));
          elements.stationSelect.innerHTML = '';
          Object.entries(stations)
            .filter(([, s]) => s.lat !== null && s.lon !== null)
            .sort((a, b) => a[1].name.localeCompare(b[1].name))
            .forEach(([id, info]) => {
              const option = document.createElement('option');
              option.value = id;
              option.textContent = utils.capitalizeWords(info.name);
              elements.stationSelect.appendChild(option);
            });
          core.restoreSavedSettings();
        } catch (error) {
          elements.lastUpdatedWeather.textContent = '';
          elements.lastUpdatedPollen.textContent = '';
          elements.errorMsg.textContent = `Error loading stations: ${error.message}`;
        }
      },
      restoreSavedSettings: () => {
        const saved = {
          stationId: localStorage.getItem(STORAGE_KEYS.STATION),
          timeRange: localStorage.getItem(STORAGE_KEYS.TIMERANGE),
          futureDays: localStorage.getItem(STORAGE_KEYS.FUTUREDAYS),
          pollens: localStorage.getItem(STORAGE_KEYS.POLLENS),
          asthmaToggle: localStorage.getItem(STORAGE_KEYS.ASTHMA_TOGGLE),
          apikey: localStorage.getItem(STORAGE_KEYS.APIKEY),
          settingsMenuOpen: localStorage.getItem(STORAGE_KEYS.SETTINGS_MENU_OPEN)
        };
        if (saved.timeRange && elements.timerangeSelect.querySelector(`option[value="${saved.timeRange}"]`)) elements.timerangeSelect.value = saved.timeRange;
        if (saved.futureDays && elements.futuredaysSelect.querySelector(`option[value="${saved.futureDays}"]`)) elements.futuredaysSelect.value = saved.futureDays;
        if (saved.pollens) {
          try { selectedPollens = new Set(JSON.parse(saved.pollens)); } catch {}
        }
        showAsthmaticRisk = saved.asthmaToggle === 'true';
        elements.asthmaToggle.checked = showAsthmaticRisk;
        elements.apikeyInput.value = saved.apikey || DEFAULT_API_KEY;
        if (saved.settingsMenuOpen !== null) {
          settingsMenu.setOpen(saved.settingsMenuOpen === 'true');
        }
        if (saved.stationId && stations[saved.stationId]) {
          elements.stationSelect.value = saved.stationId;
          core.startRefresh();
        } else if (elements.stationSelect.options.length) {
          elements.stationSelect.selectedIndex = 0;
          core.startRefresh();
        }
      },
      fetchWeatherDataAndUpdate: async () => {
        try {
          elements.errorMsg.textContent = '';
          elements.lastUpdatedWeather.textContent = 'Loading weather data...';
          const stationId = elements.stationSelect.value;
          const hoursRange = parseInt(elements.timerangeSelect.value);
          const futureHours = parseInt(elements.futuredaysSelect.value);
          const data = await dataFetch.fetchStationData(stationId, hoursRange);
          const timestamps = data.timestamps.map(ts => new Date(ts));
          const { TL, RR } = data.features[0].properties.parameters;
          const { lat, lon } = stations[stationId] || {};
          const forecast = await dataFetch.fetchFlexiForecast(lat, lon);

          // Use only hourly data points where minute == 0
          const pastData = timestamps.reduce((acc, ts, i) => ts.getMinutes() === 0 && TL?.data[i] !== null ? acc.concat({ ts, temp: TL.data[i], rr: RR?.data[i] ?? 0 }) : acc, []);
          const now = new Date(), maxFutureDate = new Date(now.getTime() + futureHours * 3600 * 1000);
          const forecastData = forecast ? forecast.timestamps.reduce((acc, ts, i) => ts.getMinutes() === 0 && ts > now && ts <= maxFutureDate && forecast.t2m[i] !== null ? acc.concat({ ts, temp: forecast.t2m[i], rr: forecast.rr[i] ?? 0 }) : acc, []) : [];
          combinedData = [...pastData, ...forecastData];

         // German day labels to fetch
          if (showAsthmaticRisk && stations[stationId].name) {
            try {
              // Fetch asthmatic risk for all 5 days in parallel
              const cityName = stations[stationId].name.split(' ')[0];
              const riskValues = await Promise.all(
                asthmaDayLabels.map(dayLabel => {
                  return dataFetch.fetchAsthmaticRisk(cityName, dayLabel);
                })
              );

              // Map these risk values to dates relative to today
              const today = new Date();
              today.setHours(0,0,0,0);

              // Calculate date offsets for Vorgestern (-2), Gestern (-1), Heute (0), Morgen (+1), Übermorgen (+2)
              const dayOffsets = [-2, -1, 0, 1, 2];

              asthmaticRiskData = dayOffsets.map((offset, idx) => {
                const date = new Date(today);
                date.setDate(today.getDate() + offset);
                return { ts: date, value: riskValues[idx] };
              });

            } catch (err) {
              console.warn('Asthmatic risk fetch failed:', err.message);
              asthmaticRiskData = [];
              elements.errorMsg.textContent = 'Warning: Asthmatic risk data not available.';
            }
          } else {
            asthmaticRiskData = [];
          }

          ui.drawChart();
          ui.updateCurrentTemp(pastData);
          lastWeatherUpdate = new Date();
          elements.lastUpdatedWeather.textContent = `Weather data last updated: ${lastWeatherUpdate.toLocaleString()}`;
        } catch (error) {
          elements.lastUpdatedWeather.textContent = '';
          elements.errorMsg.textContent = `Error loading weather data: ${error.message}`;
        }
      },
      fetchPollenDataAndUpdate: async () => {
        try {
          elements.errorMsg.textContent = '';
          elements.lastUpdatedPollen.textContent = 'Loading pollen data...';
          const stationId = elements.stationSelect.value;
          const { lat, lon } = stations[stationId] || {};
          if (!lat || !lon) throw new Error('Station coordinates not available for pollen data.');

          // Get API key from input, fallback to default
          const apiKey = elements.apikeyInput.value.trim() || DEFAULT_API_KEY;
          localStorage.setItem(STORAGE_KEYS.APIKEY, apiKey);

          pollenData = await dataFetch.fetchPollenDataNewApi(lat, lon, apiKey);
          contaminationDates = [
            pollenData.contamination_date_1 || 'Heute',
            pollenData.contamination_date_2 || '',
            pollenData.contamination_date_3 || '',
            pollenData.contamination_date_4 || ''
          ];
          if (pollenData.contamination?.length) ui.buildPollenCheckboxes(pollenData.contamination);

          lastPollenUpdate = new Date();
          elements.lastUpdatedPollen.textContent = `Pollen data last updated: ${lastPollenUpdate.toLocaleString()}`;

          ui.drawChart();
        } catch (pollenError) {
          console.error('Failed to fetch pollen data:', pollenError.message);
          elements.errorMsg.textContent = `Warning: Pollen data unavailable (${pollenError.message}). Displaying temperature and rainfall data only.`;
          pollenData = { contamination: [], allergyrisk: {} };
          contaminationDates = [];
          elements.pollenSelect.innerHTML = '<p style="color: #cc0000; font-style: italic;">Pollen data unavailable</p>';
          elements.lastUpdatedPollen.textContent = '';
          ui.drawChart();
        }
      },
      startRefresh: () => {
        if (refreshIntervalId) clearInterval(refreshIntervalId);
        core.fetchWeatherDataAndUpdate();
        core.fetchPollenDataAndUpdate();
        refreshIntervalId = setInterval(core.fetchWeatherDataAndUpdate, 900000); // 15 minutes

        if (core.pollenIntervalId) clearInterval(core.pollenIntervalId);
        core.pollenIntervalId = setInterval(core.fetchPollenDataAndUpdate, 4 * 3600 * 1000); // 4 hours
      },
      findNearestStation: position => {
        const { latitude: userLat, longitude: userLon } = position.coords;
        let minDist = Infinity, nearestStationId = null;
        for (const [id, info] of Object.entries(stations)) {
          if (info.lat === null || info.lon === null) continue;
          const dist = utils.haversineDistance(userLat, userLon, info.lat, info.lon);
          if (dist < minDist) { minDist = dist; nearestStationId = id; }
        }
        return nearestStationId;
      }
    };

    // Event Listeners
    const setupListeners = () => {
      const refreshOnChange = () => {
        const stationId = elements.stationSelect.value;
        if (stationId) {
          localStorage.setItem(STORAGE_KEYS.STATION, stationId);
          localStorage.setItem(STORAGE_KEYS.TIMERANGE, elements.timerangeSelect.value);
          localStorage.setItem(STORAGE_KEYS.FUTUREDAYS, elements.futuredaysSelect.value);
          core.fetchWeatherDataAndUpdate();
          core.fetchPollenDataAndUpdate();
        }
      };
      elements.stationSelect.addEventListener('change', refreshOnChange);
      elements.timerangeSelect.addEventListener('change', refreshOnChange);
      elements.futuredaysSelect.addEventListener('change', refreshOnChange);
      elements.corsproxyInput.addEventListener('input', () => {
        localStorage.setItem(STORAGE_KEYS.CORSPROXY, elements.corsproxyInput.value.trim());
        refreshOnChange();
      });
      elements.apikeyInput.addEventListener('change', () => {
        const val = elements.apikeyInput.value.trim();
        if (val) {
          localStorage.setItem(STORAGE_KEYS.APIKEY, val);
          core.fetchPollenDataAndUpdate();
        }
      });
      elements.asthmaToggle.addEventListener('change', () => {
        showAsthmaticRisk = elements.asthmaToggle.checked;
        localStorage.setItem(STORAGE_KEYS.ASTHMA_TOGGLE, showAsthmaticRisk.toString());
        core.fetchWeatherDataAndUpdate(); // refetch asthmatic data accordingly
      });
      elements.locationBtn.addEventListener('click', () => {
        if (!navigator.geolocation) {
          elements.errorMsg.textContent = 'Geolocation is not supported by your browser.';
          return;
        }
        elements.locationBtn.disabled = true;
        elements.locationBtn.textContent = 'Locating...';
        navigator.geolocation.getCurrentPosition(position => {
          const nearestStationId = core.findNearestStation(position);
          if (nearestStationId) {
            elements.stationSelect.value = nearestStationId;
            localStorage.setItem(STORAGE_KEYS.STATION, nearestStationId);
            core.startRefresh();
            elements.errorMsg.textContent = `Nearest station selected: ${stations[nearestStationId].name}`;
          } else {
            elements.errorMsg.textContent = 'Could not find a nearby station.';
          }
          elements.locationBtn.disabled = false;
          elements.locationBtn.textContent = 'Use My Location';
        }, err => {
          elements.errorMsg.textContent = `Geolocation error: ${err.message}`;
          elements.locationBtn.disabled = false;
          elements.locationBtn.textContent = 'Use My Location';
        }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 });
      });
      elements.darkModeToggle.addEventListener('click', () => {
        darkMode.toggle();
      });
    };

    // Initialize
    const init = async () => {
      darkMode.init();
      settingsMenu.init();
      await core.loadStations();
      setupListeners();
    };

    init();
  </script>
</body>
</html>
