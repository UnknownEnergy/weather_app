<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Temperature & Rainfall Chart - TAWES Stations with CORS Proxy Input</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0 1rem;
      background: #f7f9fc;
      color: #333;
      max-width: none;
      width: 100vw;
      box-sizing: border-box;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }
    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    .control-group {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0.3rem;
      white-space: nowrap;
    }
    label {
      font-weight: bold;
      flex-shrink: 0;
    }
    select {
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
      min-width: 140px;
      border-radius: 4px;
      border: 1px solid #ccc;
      flex-shrink: 0;
    }
    input[type="text"] {
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
      min-width: 140px;
      border-radius: 4px;
      border: 1px solid #ccc;
      flex-shrink: 0;
    }
    #location-btn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: #007bff;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      white-space: nowrap;
      flex-shrink: 0;
      align-self: center;
    }
    #location-btn:hover:not(:disabled) {
      background-color: #0056b3;
    }
    #location-btn:disabled {
      background-color: #999;
      cursor: default;
    }
    #last-updated {
      margin-top: 0.5rem;
      font-style: italic;
      color: #555;
      text-align: center;
      font-size: 0.9rem;
    }
    #error-msg {
      color: #cc0000;
      font-weight: bold;
      margin-top: 0.5rem;
      text-align: center;
      min-height: 1.2em;
      font-size: 0.95rem;
    }
    #current-temp {
      text-align: center;
      font-weight: bold;
      margin-top: 0.5rem;
      font-size: 1.1rem;
    }
    canvas {
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      width: 100%;
      height: 670px !important;
      max-height: 50%;
      display: block;
      margin: 0 auto;
      object-fit: contain;
    }
    @media (max-width: 480px) {
      .controls {
        gap: 0.75rem;
        justify-content: center;
      }
      .control-group {
        gap: 0.25rem;
      }
      label {
        font-size: 1rem;
      }
      select, input[type="text"], #location-btn {
        font-size: 1rem;
        min-width: 110px;
        padding: 0.4rem 0.5rem;
      }
      h1 {
        font-size: 1.3rem;
        margin-bottom: 1rem;
      }
      #last-updated {
        font-size: 0.85rem;
      }
      #error-msg {
        font-size: 0.9rem;
      }
      #current-temp {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Current Temperature & Rainfall (TAWES Stations)</h1>

  <div class="controls" role="region" aria-label="Station and time range selection">
    <div class="control-group">
      <label for="station-select">Station:</label>
      <select id="station-select"></select>
    </div>
    <div class="control-group">
      <label for="timerange-select">Past Range:</label>
      <select id="timerange-select" aria-label="Select time range">
        <option value="1">Past 1 hour</option>
         <option value="3">Past 3 hours</option>
        <option value="12" selected>Past 12 hours</option>
        <option value="24">Past 24 hours</option>
        <option value="72">Past 3 days</option>
        <option value="120">Past 5 days</option>
      </select>
    </div>
    <div class="control-group">
      <label for="futuredays-select">Forecast Range:</label>
      <select id="futuredays-select" aria-label="Select forecast days ahead">
        <option value="1">1 hour ahead</option>
        <option value="3">3 hour ahead</option>
        <option value="12" selected>12 hours ahead</option>
        <option value="24">24 hours ahead</option>
        <option value="72">3 days ahead</option>
        <option value="120">5 days ahead</option>
      </select>
    </div>
    <div class="control-group">
      <label for="corsproxy-input">CORS Proxy:</label>
      <input type="text" id="corsproxy-input" aria-label="Enter CORS proxy URL" placeholder="Enter CORS proxy URL">
    </div>
    <button id="location-btn" title="Find nearest station to your current location">Use My Location</button>
  </div>

  <canvas id="tempChart" width="900" height="400" aria-label="Temperature and Rainfall chart"></canvas>
  <div id="current-temp" aria-live="polite" aria-atomic="true"></div>
  <div id="last-updated"></div>
  <div id="error-msg" role="alert" aria-live="assertive"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0/dist/chartjs-plugin-annotation.min.js"></script>
  <script>
const stationSelect = document.getElementById('station-select');
const locationBtn = document.getElementById('location-btn');
const errorMsg = document.getElementById('error-msg');
const ctx = document.getElementById('tempChart').getContext('2d');
const lastUpdatedDiv = document.getElementById('last-updated');
const timerangeSelect = document.getElementById('timerange-select');
const currentTempDiv = document.getElementById('current-temp');
const futuredaysSelect = document.getElementById('futuredays-select');
const corsproxyInput = document.getElementById('corsproxy-input');

let stations = {};
let forecastPoints = [];
let tempChart;
let refreshIntervalId;

const STORAGE_KEY_STATION = 'selectedStationId';
const STORAGE_KEY_TIMERANGE = 'selectedTimeRangeHours';
const STORAGE_KEY_FUTUREDAYS = 'selectedFutureDays';
const STORAGE_KEY_CORSPROXY = 'selectedCorsProxy';

function toISOStringNoMs(date) {
  return date.toISOString().split('.')[0] + 'Z';
}

function haversineDistance(lat1, lon1, lat2, lon2) {
  const toRad = angle => angle * Math.PI / 180;
  const R = 6371000;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function applyCorsProxy(url) {
  const proxy = corsproxyInput.value.trim() || '';
  if (!proxy) return url;
  // Add trailing slash if missing
  const proxyNormalized = proxy.endsWith('/') ? proxy : proxy + '/';
  if (url.startsWith(proxyNormalized)) return url;
  // Remove leading slash from url if present to avoid double slash
  const urlNormalized = url.startsWith('/') ? url.slice(1) : url;
  return proxyNormalized + urlNormalized;
}

async function fetchWithProxy(url) {
  const proxiedUrl = applyCorsProxy(url);
  const response = await fetch(proxiedUrl);
  if (!response.ok) throw new Error(`HTTP ${response.status} fetching ${url}`);
  return response.json();
}

async function loadForecastPoints() {
  try {
    forecastPoints = await fetchWithProxy('https://www.geosphere.at/data/forecasts/points');
  } catch (err) {
    forecastPoints = [];
    throw err;
  }
}

async function loadStations() {
    const savedCorsProxy = localStorage.getItem(STORAGE_KEY_CORSPROXY);

    // Set CORS proxy input value first, with default if no saved value
    if (savedCorsProxy !== null && savedCorsProxy.trim() !== '') {
      corsproxyInput.value = savedCorsProxy.trim();
    } else {
      corsproxyInput.value = 'https://cors-anywhere.herokuapp.com/';
    }

  errorMsg.textContent = '';
  try {
    await loadForecastPoints();
    const metaData = await fetchWithProxy('https://www.geosphere.at/data/stations/tawes/points');
    if (!metaData.mapping) throw new Error('Invalid station metadata format');

    const coordData = await fetchWithProxy('https://www.geosphere.at/data/stations/tawes/current_data');
    if (!coordData.features) throw new Error('Invalid station coordinates format');

    const coordsMap = {};
    for (const feature of coordData.features) {
      const sid = String(feature.properties.station);
      const coords = feature.geometry.coordinates;
      coordsMap[sid] = { lat: coords[1], lon: coords[0] };
    }

    stations = {};
    for (const [stationId, info] of Object.entries(metaData.mapping)) {
      stations[stationId] = {
        name: info.name,
        klima_id: info.klima_id,
        elevation: info.elevation,
        lat: coordsMap[stationId]?.lat ?? null,
        lon: coordsMap[stationId]?.lon ?? null,
        point_id: info.klima_id || stationId
      };
    }

    stationSelect.innerHTML = '';
    const sortedStations = Object.entries(stations)
      .filter(([, s]) => s.lat !== null && s.lon !== null)
      .sort((a, b) => a[1].name.localeCompare(b[1].name));

    for (const [stationId, info] of sortedStations) {
      const option = document.createElement('option');
      option.value = stationId;
      option.textContent = capitalizeWords(info.name);
      stationSelect.appendChild(option);
    }

    // Load saved values
    const savedStationId = localStorage.getItem(STORAGE_KEY_STATION);
    const savedTimeRange = localStorage.getItem(STORAGE_KEY_TIMERANGE);
    const savedFutureDays = localStorage.getItem(STORAGE_KEY_FUTUREDAYS);

    // Validate and set time range and future days selects
    if (savedTimeRange && timerangeSelect.querySelector(`option[value="${savedTimeRange}"]`)) {
      timerangeSelect.value = savedTimeRange;
    }
    if (savedFutureDays && futuredaysSelect.querySelector(`option[value="${savedFutureDays}"]`)) {
      futuredaysSelect.value = savedFutureDays;
    }

    // Set station select and start loading data
    if (savedStationId && stations[savedStationId]) {
      stationSelect.value = savedStationId;
      startRefresh(savedStationId, parseInt(timerangeSelect.value), parseInt(futuredaysSelect.value));
    } else if (stationSelect.options.length > 0) {
      stationSelect.selectedIndex = 0;
      startRefresh(stationSelect.value, parseInt(timerangeSelect.value), parseInt(futuredaysSelect.value));
    }
  } catch (error) {
    lastUpdatedDiv.textContent = '';
    errorMsg.textContent = `Error loading stations: ${error.message}`;
  }
}

function capitalizeWords(str) {
  return str.toLowerCase().split(/\s+/).map(word => {
    if (word.length === 0) return '';
    return word[0].toUpperCase() + word.slice(1);
  }).join(' ');
}


function findNearestForecastPoint(lat, lon) {
  if (forecastPoints.length === 0 || lat === null || lon === null) return null;
  let minDist = Infinity;
  let nearestPointId = null;
  for (const pt of forecastPoints) {
    const dist = haversineDistance(lat, lon, pt.lat, pt.lon);
    if (dist < minDist) {
      minDist = dist;
      nearestPointId = pt.point_id;
    }
  }
  return nearestPointId;
}

async function fetchFlexiForecastForStation(lat, lon) {
  const pointId = findNearestForecastPoint(lat, lon);
  if (!pointId) return null;
  const url = `https://www.geosphere.at/data/forecasts/flexi/${pointId}`;
  const data = await fetchWithProxy(url);
  if (!data.timestamps || !data.features || data.features.length === 0) throw new Error('Invalid forecast data format.');
  const feature = data.features[0];
  const timestamps = data.timestamps.map(ts => new Date(ts));
  const params = feature.properties.parameters;
  const t2m = params.t2m?.data ?? [];
  const rr = params.rr?.data ?? []; // rainfall data added
  return { timestamps, t2m, rr };
}

async function fetchAndUpdateData(stationId, hoursRange, futureHours) {
  try {
    errorMsg.textContent = '';
    const now = new Date();
    const startDate = new Date(now.getTime() - hoursRange * 3600 * 1000);
    const endDate = now;
    // Fetch past temperature and rainfall data (10min resolution)
    const url = new URL('https://dataset.api.hub.geosphere.at/v1/station/historical/tawes-v1-10min');
    url.searchParams.set('parameters', 'TL,RR');
    url.searchParams.set('start', toISOStringNoMs(startDate));
    url.searchParams.set('end', toISOStringNoMs(endDate));
    url.searchParams.set('station_ids', stationId);
    lastUpdatedDiv.textContent = 'Loading data...';
    const data = await fetchWithProxy(url.toString());
    if (!data.features || data.features.length === 0) throw new Error('No data available for this station.');
    const timestamps = data.timestamps.map(ts => new Date(ts));
    const TL = data.features[0].properties.parameters.TL?.data ?? [];
    const RR = data.features[0].properties.parameters.RR?.data ?? [];

    // Fetch forecast data
    const lat = stations[stationId]?.lat;
    const lon = stations[stationId]?.lon;
    const forecast = await fetchFlexiForecastForStation(lat, lon);

    // Format labels for past data
    const formatLabelPast = ts => {
      if (hoursRange > 24)
        return ts.toLocaleString([], {year:'2-digit', month:'2-digit', day:'2-digit', hour12:false, hour: '2-digit', minute:'2-digit'});
      else
        return ts.toLocaleTimeString([], {hour12: false, hour: '2-digit', minute:'2-digit'});
    };

    // Format labels for forecast data
    const formatLabelForecast = ts => ts.toLocaleString([], {hour12:false, hour:'2-digit', minute:'2-digit', day:'2-digit', month:'2-digit'});

    // Initialize variables for forecast filtering
    let forecastLabels = [];
    let forecastTemps = [];
    let forecastRR = [];
    let filteredForecastIndices = [];
    let forecastTimestampsFiltered = [];

    if (forecast) {
      const maxFutureDate = new Date(now.getTime() + futureHours * 3600 * 1000);
      filteredForecastIndices = [];
      for (let i = 0; i < forecast.timestamps.length; i++) {
        const ts = forecast.timestamps[i];
        if (ts > now && ts <= maxFutureDate) filteredForecastIndices.push(i);
      }
      forecastLabels = filteredForecastIndices.map(i => formatLabelForecast(forecast.timestamps[i]));
      forecastTemps = filteredForecastIndices.map(i => forecast.t2m[i]);
      forecastRR = filteredForecastIndices.map(i => forecast.rr[i] ?? null);
      forecastTimestampsFiltered = filteredForecastIndices.map(i => forecast.timestamps[i]);
    }

    // Clean past temperature data to exclude trailing nulls
    const lastValidPastIndex = TL.slice().reverse().findIndex(val => val !== null && val !== undefined);
    const pastTempsCleaned = lastValidPastIndex >= 0 ? TL.slice(0, TL.length - lastValidPastIndex) : [];
    const pastRRCleaned = lastValidPastIndex >= 0 ? RR.slice(0, RR.length - lastValidPastIndex) : [];
    const pastLabelsCleaned = timestamps.slice(0, pastTempsCleaned.length);

    // Clean forecast temperature and rainfall data to exclude leading nulls
    const firstValidForecastIdx = forecastTemps.findIndex(val => val !== null && val !== undefined);
    const forecastTempsCleaned = firstValidForecastIdx >= 0 ? forecastTemps.slice(firstValidForecastIdx) : [];
    const forecastRRCleaned = firstValidForecastIdx >= 0 ? forecastRR.slice(firstValidForecastIdx) : [];
    const forecastLabelsCleaned = firstValidForecastIdx >= 0 ? forecastLabels.slice(firstValidForecastIdx) : [];
    const forecastTimestampsFinal = firstValidForecastIdx >= 0 ? forecastTimestampsFiltered.slice(firstValidForecastIdx) : [];

    // Combine past and forecast data
    const combinedLabels = [...pastLabelsCleaned.map(ts => formatLabelPast(ts)), ...forecastLabelsCleaned];
    const combinedTemps = [...pastTempsCleaned, ...forecastTempsCleaned];
    const combinedRR = [...pastRRCleaned, ...forecastRRCleaned];
    const combinedTimestamps = [...pastLabelsCleaned, ...forecastTimestampsFinal];

    if (tempChart) tempChart.destroy();

    // Prepare annotations for:
    // 1) Current time vertical line (if in range)
    // 2) Vertical lines at each midnight start in combinedTimestamps

    // Find index closest to now (current time) in combinedTimestamps for annotation position
    // If current time is outside range, no line

    const annotations = {};

    // 1) Current time line - find closest index or approximate position
    // Because x axis is category, annotation lines can be positioned by x value = index or label

    // Find index where combinedTimestamps[i] is closest to now
    let closestIndexToNow = null;
    let minDiffMs = Infinity;
    for(let i=0; i<combinedTimestamps.length; i++) {
      const diff = Math.abs(combinedTimestamps[i] - now);
      if(diff < minDiffMs) {
        minDiffMs = diff;
        closestIndexToNow = i;
      }
    }

    // Only add current time line if now is within the range of combinedTimestamps
    if (combinedTimestamps.length > 0) {
      const firstTime = combinedTimestamps[0];
      const lastTime = combinedTimestamps[combinedTimestamps.length - 1];
      if (now >= firstTime && now <= lastTime && closestIndexToNow !== null) {
        annotations.currentTimeLine = {
          type: 'line',
          xMin: closestIndexToNow,
          xMax: closestIndexToNow,
          borderColor: 'red',
          borderWidth: 2,
          borderDash: [6, 4],
          label: {
            content: 'Now',
            enabled: true,
            position: 'start',
            backgroundColor: 'red',
            color: 'white',
            font: { weight: 'bold' },
            yAdjust: -10,
          }
        };
      }
    }

    // 2) Vertical lines at each new day start (midnight)
    // We scan combinedTimestamps and find indices where date changes at midnight

    // We'll add vertical lines at indices where timestamp is exactly midnight (or closest to it)
    // Because data may not have exact midnight timestamp, we find timestamp closest to midnight each day

    // Collect unique days from timestamps:
    const days = new Set();

    combinedTimestamps.forEach(ts => {
      const d = new Date(ts);
      d.setHours(0,0,0,0);
      days.add(d.getTime());
    });

    // For each day start, find closest index in combinedTimestamps
    // Add an annotation line for each day start except the very first timestamp's day (to avoid line at start)

    const dayStarts = Array.from(days).sort((a,b) => a-b);

    // Helper to find closest index to a timestamp
    function findClosestIndex(ts) {
      let closestIdx = 0;
      let minDiff = Infinity;
      for(let i=0; i<combinedTimestamps.length; i++) {
        const diff = Math.abs(combinedTimestamps[i] - ts);
        if(diff < minDiff) {
          minDiff = diff;
          closestIdx = i;
        }
      }
      return closestIdx;
    }

    dayStarts.forEach((dayStartTime, idx) => {
      if (idx === 0) return; // Skip first day start to avoid line at very beginning
      const indexForDayStart = findClosestIndex(dayStartTime);
      // Add vertical line annotation
      annotations['dayStartLine' + idx] = {
        type: 'line',
        xMin: indexForDayStart,
        xMax: indexForDayStart,
        borderColor: 'rgba(0,0,0,0.15)',
        borderWidth: 1,
        borderDash: [2,3],
        label: {
          content: new Date(dayStartTime).toLocaleDateString(),
          enabled: true,
          position: 'start',
          backgroundColor: 'rgba(0,0,0,0.15)',
          color: '#333',
          font: { size: 9 },
          yAdjust: -6,
        }
      };
    });

    tempChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: combinedLabels,
        datasets: [
          {
            label: `Mean Temp (째C) - ${stations[stationId].name}`,
            data: combinedTemps,
            borderColor: 'rgba(255, 99, 132, 0.8)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            pointHoverRadius: 6,
            borderWidth: 2,
            yAxisID: 'yTemp',
            spanGaps: true,
          },
          {
            label: `Rainfall (mm) - ${stations[stationId].name}`,
            data: combinedRR,
            type: 'bar',
            backgroundColor: 'rgba(54, 162, 235, 0.5)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1,
            yAxisID: 'yRain',
            spanGaps: true,
          }
        ]
      },
      options: {
        responsive: true,
        animation: false,
        maintainAspectRatio: false,
        scales: {
          x: { 
            title: { display: true, text: 'Time' }, 
            ticks: { maxRotation: 45, minRotation: 30 }, 
            type: 'category' 
          },
          yTemp: { 
            position: 'left',
            title: { display: true, text: 'Temperature (째C)' },
            suggestedMin: 0,
            suggestedMax: 40,
            grid: { drawOnChartArea: true },
          },
          yRain: { 
            position: 'right',
            title: { display: true, text: 'Rainfall (mm)' },
            grid: { drawOnChartArea: false },
            min: 0,
          }
        },
        plugins: {
          legend: { display: true },
          tooltip: { 
            mode: 'index', 
            intersect: false,
            callbacks: { 
              label: ctx => {
                if(ctx.dataset.label.includes('Temp')) return `Temp: ${ctx.parsed.y} 째C`;
                if(ctx.dataset.label.includes('Rainfall')) return `Rainfall: ${ctx.parsed.y} mm`;
                return `${ctx.dataset.label}: ${ctx.parsed.y}`;
              }
            }
          },
          annotation: {
            annotations: {
              forecastBox: {
                type: 'box',
                xMin: pastLabelsCleaned.length,
                xMax: combinedLabels.length - 1,
                backgroundColor: 'rgba(200, 200, 255, 0.15)',
                borderWidth: 0,
              },
              ...annotations
            }
          }
        },
        interaction: { mode: 'nearest', intersect: false }
      },
      plugins: [Chart.registry.getPlugin('annotation')].filter(Boolean)
    });

    // Display latest temperature and rainfall info for past data only
    const lastValidTempIndex = pastTempsCleaned.length - 1;
    const latestTemp = pastTempsCleaned[lastValidTempIndex];
    const latestRainfall = pastRRCleaned[lastValidTempIndex];
    const latestTime = pastLabelsCleaned.length > 0 ? formatLabelPast(pastLabelsCleaned[lastValidTempIndex]) : '';
    const tempText = (latestTemp !== null && latestTemp !== undefined) ? `${latestTemp} 째C` : 'No temp data';
    const rainText = (latestRainfall !== null && latestRainfall !== undefined) ? `${latestRainfall.toFixed(2)} mm` : 'No rainfall data';
    currentTempDiv.textContent = `Latest (at ${latestTime}): Temperature: ${tempText}, Rainfall: ${rainText}`;

    lastUpdatedDiv.textContent = `Last updated: ${new Date().toLocaleString()}`;
  } catch (error) {
    lastUpdatedDiv.textContent = '';
    currentTempDiv.textContent = '';
    errorMsg.textContent = `Error loading data: ${error.message}`;
  }
}

function startRefresh(stationId, hoursRange, futureHours) {
  if (refreshIntervalId) clearInterval(refreshIntervalId);
  fetchAndUpdateData(stationId, hoursRange, futureHours);
  refreshIntervalId = setInterval(() => fetchAndUpdateData(stationId, hoursRange, futureHours), 300000);
}

stationSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureHours = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_STATION, selectedStation);
    startRefresh(selectedStation, selectedRange, selectedFutureHours);
  }
});

timerangeSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureHours = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_TIMERANGE, selectedRange);
    startRefresh(selectedStation, selectedRange, selectedFutureHours);
  }
});

futuredaysSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureHours = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_FUTUREDAYS, selectedFutureHours);
    startRefresh(selectedStation, selectedRange, selectedFutureHours);
  }
});

// Use 'input' event to listen for character changes in the CORS proxy input
corsproxyInput.addEventListener('input', () => {
  const selectedProxy = corsproxyInput.value.trim();
  localStorage.setItem(STORAGE_KEY_CORSPROXY, selectedProxy);
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureHours = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    startRefresh(selectedStation, selectedRange, selectedFutureHours);
  }
});

locationBtn.addEventListener('click', () => {
  errorMsg.textContent = '';
  if (!navigator.geolocation) {
    errorMsg.textContent = 'Geolocation is not supported by your browser.';
    return;
  }
  locationBtn.disabled = true;
  locationBtn.textContent = 'Locating...';
  navigator.geolocation.getCurrentPosition(position => {
    const userLat = position.coords.latitude;
    const userLon = position.coords.longitude;
    let minDist = Infinity;
    let nearestStationId = null;
    for (const [stationId, info] of Object.entries(stations)) {
      if (info.lat === null || info.lon === null) continue;
      const dist = haversineDistance(userLat, userLon, info.lat, info.lon);
      if (dist < minDist) {
        minDist = dist;
        nearestStationId = stationId;
      }
    }
    if (nearestStationId) {
      stationSelect.value = nearestStationId;
      localStorage.setItem(STORAGE_KEY_STATION, nearestStationId);
      const selectedRange = parseInt(timerangeSelect.value);
      const selectedFutureHours = parseInt(futuredaysSelect.value);
      startRefresh(nearestStationId, selectedRange, selectedFutureHours);
      errorMsg.textContent = `Nearest station selected: ${stations[nearestStationId].name}`;
    } else {
      errorMsg.textContent = 'Could not find a nearby station.';
    }
    locationBtn.disabled = false;
    locationBtn.textContent = 'Use My Location';
  }, err => {
    errorMsg.textContent = `Geolocation error: ${err.message}`;
    locationBtn.disabled = false;
    locationBtn.textContent = 'Use My Location';
  }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 });
});

loadStations();
  </script>
</body>
</html>
