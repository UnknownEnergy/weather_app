<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Temperature, Rainfall, Pollen & Asthmatic Risk</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0 1rem;
      background: #f7f9fc;
      color: #333;
      width: 100vw;
      box-sizing: border-box;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }
    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      white-space: nowrap;
    }
    label {
      font-weight: bold;
      flex-shrink: 0;
    }
    select, input[type="text"] {
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
      min-width: 140px;
      border-radius: 4px;
      border: 1px solid #ccc;
      flex-shrink: 0;
    }
    #location-btn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: #007bff;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
      align-self: center;
    }
    #location-btn:hover:not(:disabled) { background-color: #0056b3; }
    #location-btn:disabled { background-color: #999; cursor: default; }
    #last-updated {
      margin-top: 0.5rem;
      font-style: italic;
      color: #555;
      text-align: center;
      font-size: 0.9rem;
    }
    #error-msg {
      color: #cc0000;
      font-weight: bold;
      margin-top: 0.5rem;
      text-align: center;
      min-height: 1.2em;
      font-size: 0.95rem;
    }
    #current-temp {
      text-align: center;
      font-weight: bold;
      margin-top: 0.5rem;
      font-size: 1.1rem;
    }
    #pollen-select {
      max-height: 150px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 0.5rem;
      font-size: 0.9rem;
      min-width: 200px;
    }
    #pollen-select label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      cursor: pointer;
    }
    canvas {
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      width: 100%;
      height: 700px !important;
      max-height: 50%;
      margin: 0 auto;
      display: block;
      object-fit: contain;
    }
    @media (max-width: 480px) {
      .controls { gap: 0.75rem; justify-content: center; }
      .control-group { gap: 0.25rem; }
      label, select, input[type="text"], #location-btn { font-size: 1rem; min-width: 110px; padding: 0.4rem 0.5rem; }
      h1 { font-size: 1.3rem; margin-bottom: 1rem; }
      #last-updated { font-size: 0.85rem; }
      #error-msg { font-size: 0.9rem; }
      #current-temp { font-size: 1rem; }
      #pollen-select { min-width: 150px; max-height: 120px; }
    }
  </style>
</head>
<body>
  <h1>Temperature, Rainfall, Pollen Contamination & Asthmatic Risk</h1>
  <div class="controls" role="region" aria-label="Station and time range selection">
    <div class="control-group">
      <label for="station-select">Station:</label>
      <select id="station-select"></select>
    </div>
    <div class="control-group">
      <label for="timerange-select">Past Range:</label>
      <select id="timerange-select" aria-label="Select time range">
        <option value="1">Past 1 hour</option>
        <option value="3">Past 3 hours</option>
        <option value="12" selected>Past 12 hours</option>
        <option value="24">Past 24 hours</option>
        <option value="72">Past 3 days</option>
        <option value="120">Past 5 days</option>
      </select>
    </div>
    <div class="control-group">
      <label for="futuredays-select">Forecast Range:</label>
      <select id="futuredays-select" aria-label="Select forecast days ahead">
        <option value="1">1 hour ahead</option>
        <option value="3">3 hour ahead</option>
        <option value="12" selected>12 hours ahead</option>
        <option value="24">24 hours ahead</option>
        <option value="72">3 days ahead</option>
        <option value="120">5 days ahead</option>
      </select>
    </div>
    <div class="control-group" style="flex-direction: column;">
      <label for="pollen-select" style="font-weight:bold; margin-bottom:0.25rem;">Select Pollens:</label>
      <div id="pollen-select" role="group" aria-label="Select pollens to display contamination"></div>
    </div>
    <div class="control-group">
      <label for="asthma-toggle">Show Asthmatic Risk:</label>
      <input type="checkbox" id="asthma-toggle" aria-label="Toggle Asthmatic Risk chart display">
    </div>
    <div class="control-group">
      <label for="corsproxy-input">CORS Proxy:</label>
      <input type="text" id="corsproxy-input" aria-label="Enter CORS proxy URL" placeholder="Enter CORS proxy URL">
    </div>
    <button id="location-btn" title="Find nearest station to your current location">Use My Location</button>
  </div>
  <canvas id="tempChart" width="900" height="400" aria-label="Temperature, Rainfall, Pollen Contamination and Asthmatic Risk chart"></canvas>
  <div id="current-temp" aria-live="polite" aria-atomic="true"></div>
  <div id="last-updated"></div>
  <div id="error-msg" role="alert" aria-live="assertive"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0/dist/chartjs-plugin-annotation.min.js"></script>
  <script>
    Chart.register(window['chartjs-plugin-annotation']);

    // DOM Elements
    const elements = {
      stationSelect: document.getElementById('station-select'),
      locationBtn: document.getElementById('location-btn'),
      errorMsg: document.getElementById('error-msg'),
      ctx: document.getElementById('tempChart').getContext('2d'),
      lastUpdated: document.getElementById('last-updated'),
      timerangeSelect: document.getElementById('timerange-select'),
      currentTemp: document.getElementById('current-temp'),
      futuredaysSelect: document.getElementById('futuredays-select'),
      corsproxyInput: document.getElementById('corsproxy-input'),
      pollenSelect: document.getElementById('pollen-select'),
      asthmaToggle: document.getElementById('asthma-toggle')
    };

    // State Variables
    let stations = {}, forecastPoints = [], tempChart, refreshIntervalId;
    let pollenData = null, selectedPollens = new Set(), contaminationDates = [];
    let asthmaticRiskData = [], showAsthmaticRisk = false, combinedData = [];

    // Storage Keys
    const STORAGE_KEYS = {
      STATION: 'selectedStationId',
      TIMERANGE: 'selectedTimeRangeHours',
      FUTUREDAYS: 'selectedFutureDays',
      CORSPROXY: 'selectedCorsProxy',
      POLLENS: 'selectedPollens',
      ASTHMA_TOGGLE: 'showAsthmaticRisk'
    };

    // Utility Functions
    const utils = {
      toISOStringNoMs: date => date.toISOString().split('.')[0] + 'Z',
      capitalizeWords: str => str.toLowerCase().split(/\s+/).map(word => word ? word[0].toUpperCase() + word.slice(1) : '').join(' '),
      haversineDistance: (lat1, lon1, lat2, lon2) => {
        const toRad = angle => angle * Math.PI / 180, R = 6371000;
        const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      },
      applyCorsProxy: url => {
        const proxy = elements.corsproxyInput.value.trim();
        if (!proxy) return url;
        const proxyNormalized = proxy.endsWith('/') ? proxy : proxy + '/';
        return url.startsWith(proxyNormalized) ? url : proxyNormalized + (url.startsWith('/') ? url.slice(1) : url);
      },
      fetchWithProxy: async url => {
        const response = await fetch(utils.applyCorsProxy(url));
        if (!response.ok) throw new Error(`HTTP ${response.status} fetching ${url}`);
        return response.json();
      },
      interpolateTemp: (ts1, temp1, ts2, temp2, targetTs) => {
        const t1 = ts1.getTime(), t2 = ts2.getTime(), t = targetTs.getTime();
        return t2 === t1 ? temp1 : temp1 + ((t - t1) / (t2 - t1)) * (temp2 - temp1);
      },
      randomColorForId: (id, opacity = 1) => {
        const colors = [
          'rgba(255, 99, 132, OPACITY)', 'rgba(54, 162, 235, OPACITY)', 'rgba(255, 206, 86, OPACITY)',
          'rgba(75, 192, 192, OPACITY)', 'rgba(153, 102, 255, OPACITY)', 'rgba(255, 159, 64, OPACITY)',
          'rgba(199, 199, 199, OPACITY)', 'rgba(83, 102, 255, OPACITY)', 'rgba(255, 99, 255, OPACITY)',
          'rgba(99, 255, 132, OPACITY)'
        ];
        return colors[Number(id) % colors.length].replace('OPACITY', opacity);
      }
    };

    // Data Fetching
    const dataFetch = {
      loadForecastPoints: async () => {
        forecastPoints = await utils.fetchWithProxy('https://www.geosphere.at/data/forecasts/points') || [];
      },
      findNearestForecastPoint: (lat, lon) => {
        if (!forecastPoints.length || lat === null || lon === null) return null;
        let minDist = Infinity, nearestPointId = null;
        for (const pt of forecastPoints) {
          const dist = utils.haversineDistance(lat, lon, pt.lat, pt.lon);
          if (dist < minDist) { minDist = dist; nearestPointId = pt.point_id; }
        }
        return nearestPointId;
      },
      fetchFlexiForecast: async (lat, lon) => {
        const pointId = dataFetch.findNearestForecastPoint(lat, lon);
        if (!pointId) return null;
        const data = await utils.fetchWithProxy(`https://www.geosphere.at/data/forecasts/flexi/${pointId}`);
        if (!data.timestamps || !data.features?.length) throw new Error('Invalid forecast data format.');
        const { timestamps, features: [{ properties: { parameters } }] } = data;
        return {
          timestamps: timestamps.map(ts => new Date(ts)),
          t2m: parameters.t2m?.data ?? [],
          rr: parameters.rr?.data ?? []
        };
      },
      fetchPollenData: async (lat, lon) => {
        const url = `https://www.polleninformation.at/index.php?eID=appinterface&pure_json=1&lang_code=de&lang_id=0&action=getFullContaminationData&type=gps&value%5Blatitude%5D=${lat}&value%5Blongitude%5D=${lon}&country_id=1&personal_contamination=false&sensitivity=0&country=AT`;
        const data = await utils.fetchWithProxy(url);
        if (!data.success || !data.result) throw new Error('Invalid pollen contamination data');
        return data.result;
      },
      fetchStationData: async (stationId, hoursRange) => {
        const now = new Date(), startDate = new Date(now.getTime() - hoursRange * 3600 * 1000);
        const url = new URL('https://dataset.api.hub.geosphere.at/v1/station/historical/tawes-v1-10min');
        url.searchParams.set('parameters', 'TL,RR');
        url.searchParams.set('start', utils.toISOStringNoMs(startDate));
        url.searchParams.set('end', utils.toISOStringNoMs(now));
        url.searchParams.set('station_ids', stationId);
        const data = await utils.fetchWithProxy(url.toString());
        if (!data.features?.length) throw new Error('No data available for this station.');
        return data;
      }
    };

    // UI Updates
    const ui = {
      buildPollenCheckboxes: contamination => {
        elements.pollenSelect.innerHTML = '';
        contamination.forEach(p => {
          const id = `pollen-checkbox-${p.poll_id}`, checked = selectedPollens.has(String(p.poll_id));
          const label = document.createElement('label');
          label.htmlFor = id;
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = id;
          checkbox.value = p.poll_id;
          checkbox.checked = checked;
          checkbox.setAttribute('aria-label', `Toggle contamination for ${p.poll_title}`);
          label.append(checkbox, Object.assign(document.createElement('span'), { textContent: p.poll_title }));
          elements.pollenSelect.appendChild(label);
          checkbox.addEventListener('change', () => {
            checkbox.checked ? selectedPollens.add(checkbox.value) : selectedPollens.delete(checkbox.value);
            localStorage.setItem(STORAGE_KEYS.POLLENS, JSON.stringify([...selectedPollens]));
            if (pollenData) ui.drawChart();
          });
        });
      },
      updateCurrentTemp: data => {
        const latest = data.length ? data[data.length - 1] : null;
        elements.currentTemp.textContent = latest
          ? `Latest (at ${latest.ts.toLocaleTimeString([], { hour12: false, hour: '2-digit' })}): Temperature: ${latest.temp} °C, Rainfall: ${latest.rr.toFixed(2)} mm`
          : 'No recent data available.';
      },
      drawChart: () => {
        if (tempChart) tempChart.destroy();
        const startDate = new Date(combinedData[0].ts), endDate = new Date(combinedData[combinedData.length - 1].ts);
        const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        const labels = combinedData.map(d => d.ts.toLocaleString([], { hour12: false, hour: '2-digit', minute: '2-digit' }));
        const today = new Date(); today.setHours(0, 0, 0, 0);

        const mapDailyToHourly = (dailyData, numDays) => combinedData.map(({ ts }) => {
          const currentDate = new Date(ts); currentDate.setHours(0, 0, 0, 0);
          const dayIndex = Math.floor((currentDate - today) / (1000 * 60 * 60 * 24));
          return dayIndex >= 0 && dayIndex < numDays && dailyData[dayIndex] !== undefined ? dailyData[dayIndex] : null;
        });

        const contaminationDatasets = pollenData?.contamination?.filter(p => selectedPollens.has(String(p.poll_id))).map(p => ({
            label: p.poll_title,
            data: mapDailyToHourly([p.contamination_1 ?? 0, p.contamination_2 ?? 0, p.contamination_3 ?? 0, p.contamination_4 ?? 0], 4),
            backgroundColor: utils.randomColorForId(p.poll_id, 0.2),
            borderColor: utils.randomColorForId(p.poll_id, 0.9),
            type: 'line',
            fill: true,
            tension: 0.4,
            pointRadius: 3,
            pointHoverRadius: 5,
            pointBackgroundColor: utils.randomColorForId(p.poll_id, 1),
            pointBorderColor: utils.randomColorForId(p.poll_id, 1),
            pointBorderWidth: 1,
            borderWidth: 2,
            yAxisID: 'yPollen',
            spanGaps: true,
            order: 4
            })) || [];


        const datasets = [
          {
            label: `Mean Temp (°C)`,
            data: combinedData.map(d => d.temp),
            borderColor: 'rgba(255, 99, 132, 0.9)',
            backgroundColor: 'rgba(255, 99, 132, 0.15)',
            fill: true,
            tension: 0.4,
            pointRadius: 3,
            pointHoverRadius: 5,
            pointBackgroundColor: 'rgba(255, 99, 132, 1)',
            pointBorderColor: 'rgba(255, 99, 132, 1)',
            pointBorderWidth: 1,
            borderWidth: 2.5,
            yAxisID: 'yTemp',
            spanGaps: true,
            order: 3
          },
          {
            label: `Rainfall (mm)`,
            data: combinedData.map(d => d.rr),
            type: 'bar',
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 0.9)',
            borderWidth: 1.5,
            hoverBackgroundColor: 'rgba(54, 162, 235, 0.8)',
            hoverBorderWidth: 2,
            hoverBorderColor: 'rgba(54, 162, 235, 1)',
            barPercentage: 0.8,
            categoryPercentage: 0.9,
            yAxisID: 'yRain',
            spanGaps: true,
            order: 1
          },
          ...contaminationDatasets
        ];

        if (showAsthmaticRisk) {
        datasets.push({
            label: 'Asthmatic Risk',
            data: mapDailyToHourly(asthmaticRiskData, asthmaticRiskData.length),
            borderColor: 'rgba(0, 102, 204, 0.9)',
            backgroundColor: 'rgba(0, 102, 204, 0.2)',
            yAxisID: 'yAsthma',
            type: 'line',
            fill: false,
            tension: 0.4,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: 'rgba(0, 102, 204, 1)',
            pointBorderColor: 'rgba(0, 102, 204, 1)',
            pointBorderWidth: 1.5,
            borderWidth: 2.5,
            spanGaps: true,
            order: 2
        });
        }

        const now = new Date(), annotations = {};
        let nowX = null, nowTemp = null;
        if (combinedData.length === 1 && Math.abs(combinedData[0].ts.getTime() - now.getTime()) <= 30 * 60 * 1000) {
          nowX = 0; nowTemp = combinedData[0].temp;
        } else if (combinedData.length > 1) {
          for (let i = 0; i < combinedData.length - 1; i++) {
            const t0 = combinedData[i].ts.getTime(), t1 = combinedData[i + 1].ts.getTime();
            if (now.getTime() >= t0 && now.getTime() <= t1) {
              nowX = i + (now.getTime() - t0) / (t1 - t0);
              nowTemp = utils.interpolateTemp(combinedData[i].ts, combinedData[i].temp, combinedData[i + 1].ts, combinedData[i + 1].temp, now);
              break;
            }
          }
          if (nowX === null) {
            nowX = now.getTime() < combinedData[0].ts.getTime() ? 0 : combinedData.length - 1;
            nowTemp = combinedData[nowX].temp;
          }
        }

        combinedData.forEach(({ ts }, i) => {
          if (ts.getHours() === 0 && ts.getMinutes() === 0 && i > 0) {
            annotations['midnightLine' + i] = {
              type: 'line', xMin: i, xMax: i, borderColor: 'rgba(100, 100, 100, 0.3)',
              borderWidth: 1.5, borderDash: [5, 5], label: {
                content: ts.toLocaleDateString(undefined, { weekday: 'short', day: 'numeric', month: 'short' }),
                enabled: true, position: 'top', backgroundColor: 'rgba(50, 50, 50, 0.7)', color: '#fff',
                font: { size: 10, weight: 'bold' }, yAdjust: 0, padding: 4
              }
            };
          }
        });

        if (nowX !== null && nowTemp !== null) {
          annotations['nowLine'] = {
            type: 'line', xMin: nowX, xMax: nowX, borderColor: 'rgba(220, 53, 69, 0.8)', borderWidth: 2,
            borderDash: [6, 4], label: {
              content: `Now: ${nowTemp.toFixed(1)} °C`, enabled: true, position: 'top',
              backgroundColor: 'rgba(220, 53, 69, 0.9)', color: 'white', font: { weight: 'bold', size: 11 },
              yAdjust: 0, xAdjust: 0, padding: 6
            }
          };
        }

        tempChart = new Chart(elements.ctx, {
          type: 'line',
          data: { labels, datasets },
          options: {
            responsive: true,
            animation: { duration: 1000, easing: 'easeInOutQuad' },
            maintainAspectRatio: false,
            layout: { padding: { left: 10, right: 10, top: 10, bottom: 10 } },
            scales: {
              x: { title: { display: true, text: `Time (Hours over ${daysDiff} Day${daysDiff > 1 ? 's' : ''})`, font: { size: 14, weight: 'bold' }, color: '#333' }, ticks: { maxRotation: 45, minRotation: 30, autoSkip: true, maxTicksLimit: 24 * daysDiff, font: { size: 11 }, color: '#555' }, grid: { drawOnChartArea: false, color: 'rgba(0, 0, 0, 0.1)' }, type: 'category' },
              yTemp: { position: 'left', title: { display: true, text: 'Temperature (°C)', font: { size: 14, weight: 'bold' }, color: '#333' }, suggestedMin: 0, suggestedMax: 40, grid: { drawOnChartArea: true, color: 'rgba(0, 0, 0, 0.05)', lineWidth: 1 }, ticks: { stepSize: 5, font: { size: 11 }, color: '#555' } },
              yRain: { position: 'right', title: { display: true, text: 'Rainfall (mm)', font: { size: 14, weight: 'bold' }, color: '#333' }, grid: { drawOnChartArea: false, color: 'rgba(0, 0, 0, 0.05)' }, min: 0, max: 15, ticks: { stepSize: 3, font: { size: 11 }, color: '#555' } },
              yPollen: { position: 'right', offset: true, title: { display: true, text: 'Pollen Contamination (0-4)', font: { size: 14, weight: 'bold' }, color: '#333' }, grid: { drawOnChartArea: false, color: 'rgba(0, 0, 0, 0.05)' }, min: 0, max: 4, ticks: { stepSize: 1, font: { size: 11 }, color: '#555' }, type: 'linear' },
              yAsthma: { position: 'left', offset: true, title: { display: showAsthmaticRisk, text: 'Asthmatic Risk (1-5)', font: { size: 14, weight: 'bold' }, color: '#333' }, grid: { drawOnChartArea: false, color: 'rgba(0, 0, 0, 0.05)' }, min: 1, max: 5, ticks: { stepSize: 1, font: { size: 11 }, color: '#555' }, type: 'linear', display: showAsthmaticRisk }
            },
            plugins: {
              legend: { display: true, position: 'top', align: 'center', maxHeight: 30, labels: { font: { size: 12 }, color: '#333', padding: 15, boxWidth: 20, usePointStyle: true } },
              tooltip: { mode: 'index', intersect: false, position: 'nearest', backgroundColor: 'rgba(255, 255, 255, 0.95)', titleColor: '#333', bodyColor: '#333', titleFont: { size: 13, weight: 'bold' }, bodyFont: { size: 12 }, padding: 10, boxPadding: 5, borderColor: 'rgba(0, 0, 0, 0.2)', borderWidth: 1, callbacks: { label: ctx => `${ctx.dataset.label.split(' - ')[0]}: ${ctx.parsed.y}${ctx.dataset.label.includes('Temp') ? ' °C' : ctx.dataset.label.includes('Rainfall') ? ' mm' : ''}` } },
              annotation: { annotations },
              datalabels: { display: false }
            },
            interaction: { mode: 'nearest', intersect: false, hover: { mode: 'index' } }
          }
        });
      }
    };

    // Core Logic
    const core = {
      loadStations: async () => {
        elements.errorMsg.textContent = '';
        const savedCorsProxy = localStorage.getItem(STORAGE_KEYS.CORSPROXY);
        elements.corsproxyInput.value = savedCorsProxy?.trim() || 'https://cors-anywhere-agfr.onrender.com/';
        try {
          await dataFetch.loadForecastPoints();
          const metaData = await utils.fetchWithProxy('https://www.geosphere.at/data/stations/tawes/points');
          const coordData = await utils.fetchWithProxy('https://www.geosphere.at/data/stations/tawes/current_data');
          if (!metaData.mapping || !coordData.features) throw new Error('Invalid station data format');
          const coordsMap = Object.fromEntries(coordData.features.map(f => [String(f.properties.station), { lat: f.geometry.coordinates[1], lon: f.geometry.coordinates[0] }]));
          stations = Object.fromEntries(Object.entries(metaData.mapping).map(([id, info]) => [id, {
            name: info.name, klima_id: info.klima_id, elevation: info.elevation,
            lat: coordsMap[id]?.lat ?? null, lon: coordsMap[id]?.lon ?? null, point_id: info.klima_id || id
          }]));
          elements.stationSelect.innerHTML = '';
          Object.entries(stations)
            .filter(([, s]) => s.lat !== null && s.lon !== null)
            .sort((a, b) => a[1].name.localeCompare(b[1].name))
            .forEach(([id, info]) => {
              const option = document.createElement('option');
              option.value = id;
              option.textContent = utils.capitalizeWords(info.name);
              elements.stationSelect.appendChild(option);
            });
          core.restoreSavedSettings();
        } catch (error) {
          elements.lastUpdated.textContent = '';
          elements.errorMsg.textContent = `Error loading stations: ${error.message}`;
        }
      },
      restoreSavedSettings: () => {
        const saved = {
          stationId: localStorage.getItem(STORAGE_KEYS.STATION),
          timeRange: localStorage.getItem(STORAGE_KEYS.TIMERANGE),
          futureDays: localStorage.getItem(STORAGE_KEYS.FUTUREDAYS),
          pollens: localStorage.getItem(STORAGE_KEYS.POLLENS),
          asthmaToggle: localStorage.getItem(STORAGE_KEYS.ASTHMA_TOGGLE)
        };
        if (saved.timeRange && elements.timerangeSelect.querySelector(`option[value="${saved.timeRange}"]`)) elements.timerangeSelect.value = saved.timeRange;
        if (saved.futureDays && elements.futuredaysSelect.querySelector(`option[value="${saved.futureDays}"]`)) elements.futuredaysSelect.value = saved.futureDays;
        if (saved.pollens) try { selectedPollens = new Set(JSON.parse(saved.pollens)); } catch {}
        showAsthmaticRisk = saved.asthmaToggle === 'true';
        elements.asthmaToggle.checked = showAsthmaticRisk;
        if (saved.stationId && stations[saved.stationId]) {
          elements.stationSelect.value = saved.stationId;
          core.startRefresh();
        } else if (elements.stationSelect.options.length) {
          elements.stationSelect.selectedIndex = 0;
          core.startRefresh();
        }
      },
      fetchAndUpdateData: async () => {
        try {
          elements.errorMsg.textContent = '';
          elements.lastUpdated.textContent = 'Loading data...';
          const stationId = elements.stationSelect.value;
          const hoursRange = parseInt(elements.timerangeSelect.value);
          const futureHours = parseInt(elements.futuredaysSelect.value);
          const data = await dataFetch.fetchStationData(stationId, hoursRange);
          const timestamps = data.timestamps.map(ts => new Date(ts));
          const { TL, RR } = data.features[0].properties.parameters;
          const { lat, lon } = stations[stationId] || {};
          const forecast = await dataFetch.fetchFlexiForecast(lat, lon);
          pollenData = await dataFetch.fetchPollenData(lat, lon);
          contaminationDates = [pollenData.contamination_date_1 || 'Today', pollenData.contamination_date_2 || '', pollenData.contamination_date_3 || '', pollenData.contamination_date_4 || ''];
          asthmaticRiskData = pollenData.additionalForecastData?.slice(0, 4).map(d => 3 - d.asthma_weather) || [];
          if (pollenData.contamination?.length) ui.buildPollenCheckboxes(pollenData.contamination);
          const pastData = timestamps.reduce((acc, ts, i) => ts.getMinutes() === 0 && TL?.data[i] !== null ? acc.concat({ ts, temp: TL.data[i], rr: RR?.data[i] ?? 0 }) : acc, []);
          const now = new Date(), maxFutureDate = new Date(now.getTime() + futureHours * 3600 * 1000);
          const forecastData = forecast ? forecast.timestamps.reduce((acc, ts, i) => ts.getMinutes() === 0 && ts > now && ts <= maxFutureDate && forecast.t2m[i] !== null ? acc.concat({ ts, temp: forecast.t2m[i], rr: forecast.rr[i] ?? 0 }) : acc, []) : [];
          combinedData = [...pastData, ...forecastData];
          ui.drawChart();
          ui.updateCurrentTemp(pastData);
          elements.lastUpdated.textContent = `Last updated: ${new Date().toLocaleString()}`;
        } catch (error) {
          elements.lastUpdated.textContent = elements.currentTemp.textContent = '';
          elements.errorMsg.textContent = `Error loading data: ${error.message}`;
        }
      },
      startRefresh: () => {
        if (refreshIntervalId) clearInterval(refreshIntervalId);
        core.fetchAndUpdateData();
        refreshIntervalId = setInterval(core.fetchAndUpdateData, 300000);
      },
      findNearestStation: position => {
        const { latitude: userLat, longitude: userLon } = position.coords;
        let minDist = Infinity, nearestStationId = null;
        for (const [id, info] of Object.entries(stations)) {
          if (info.lat === null || info.lon === null) continue;
          const dist = utils.haversineDistance(userLat, userLon, info.lat, info.lon);
          if (dist < minDist) { minDist = dist; nearestStationId = id; }
        }
        return nearestStationId;
      }
    };
// Event Listeners
    const setupListeners = () => {
      const refreshOnChange = () => {
        const stationId = elements.stationSelect.value;
        if (stationId) {
          localStorage.setItem(STORAGE_KEYS.STATION, stationId);
          localStorage.setItem(STORAGE_KEYS.TIMERANGE, elements.timerangeSelect.value);
          localStorage.setItem(STORAGE_KEYS.FUTUREDAYS, elements.futuredaysSelect.value);
          core.startRefresh();
        }
      };
      elements.stationSelect.addEventListener('change', refreshOnChange);
      elements.timerangeSelect.addEventListener('change', refreshOnChange);
      elements.futuredaysSelect.addEventListener('change', refreshOnChange);
      elements.corsproxyInput.addEventListener('input', () => {
        localStorage.setItem(STORAGE_KEYS.CORSPROXY, elements.corsproxyInput.value.trim());
        refreshOnChange();
      });
      elements.asthmaToggle.addEventListener('change', () => {
        showAsthmaticRisk = elements.asthmaToggle.checked;
        localStorage.setItem(STORAGE_KEYS.ASTHMA_TOGGLE, showAsthmaticRisk.toString());
        ui.drawChart();
      });
      elements.locationBtn.addEventListener('click', () => {
        if (!navigator.geolocation) {
          elements.errorMsg.textContent = 'Geolocation is not supported by your browser.';
          return;
        }
        elements.locationBtn.disabled = true;
        elements.locationBtn.textContent = 'Locating...';
        navigator.geolocation.getCurrentPosition(position => {
          const nearestStationId = core.findNearestStation(position);
          if (nearestStationId) {
            elements.stationSelect.value = nearestStationId;
            localStorage.setItem(STORAGE_KEYS.STATION, nearestStationId);
            core.startRefresh();
            elements.errorMsg.textContent = `Nearest station selected: ${stations[nearestStationId].name}`;
          } else {
            elements.errorMsg.textContent = 'Could not find a nearby station.';
          }
          elements.locationBtn.disabled = false;
          elements.locationBtn.textContent = 'Use My Location';
        }, err => {
          elements.errorMsg.textContent = `Geolocation error: ${err.message}`;
          elements.locationBtn.disabled = false;
          elements.locationBtn.textContent = 'Use My Location';
        }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 });
      });
    };

    // Initialize
    const init = async () => {
      await core.loadStations();
      setupListeners();
    };

    init();
  </script>
</body>
</html>
