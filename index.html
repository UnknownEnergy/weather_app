<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Temperature Chart - TAWES Stations with CORS Proxy Input</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0 1rem;
      background: #f7f9fc;
      color: #333;
      max-width: none;
      width: 100vw;
      box-sizing: border-box;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }
    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    .control-group {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0.3rem;
      white-space: nowrap;
    }
    label {
      font-weight: bold;
      flex-shrink: 0;
    }
    select {
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
      min-width: 140px;
      border-radius: 4px;
      border: 1px solid #ccc;
      flex-shrink: 0;
    }
    input[type="text"] {
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
      min-width: 140px;
      border-radius: 4px;
      border: 1px solid #ccc;
      flex-shrink: 0;
    }
    #location-btn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: #007bff;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      white-space: nowrap;
      flex-shrink: 0;
      align-self: center;
    }
    #location-btn:hover:not(:disabled) {
      background-color: #0056b3;
    }
    #location-btn:disabled {
      background-color: #999;
      cursor: default;
    }
    #last-updated {
      margin-top: 0.5rem;
      font-style: italic;
      color: #555;
      text-align: center;
      font-size: 0.9rem;
    }
    #error-msg {
      color: #cc0000;
      font-weight: bold;
      margin-top: 0.5rem;
      text-align: center;
      min-height: 1.2em;
      font-size: 0.95rem;
    }
    #current-temp {
      text-align: center;
      font-weight: bold;
      margin-top: 0.5rem;
      font-size: 1.1rem;
    }
    canvas {
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      width: 100%;
      height: 670px !important;
      max-height: 50%;
      display: block;
      margin: 0 auto;
      object-fit: contain;
    }
    @media (max-width: 480px) {
      .controls {
        gap: 0.75rem;
        justify-content: center;
      }
      .control-group {
        gap: 0.25rem;
      }
      label {
        font-size: 1rem;
      }
      select, input[type="text"], #location-btn {
        font-size: 1rem;
        min-width: 110px;
        padding: 0.4rem 0.5rem;
      }
      h1 {
        font-size: 1.3rem;
        margin-bottom: 1rem;
      }
      #last-updated {
        font-size: 0.85rem;
      }
      #error-msg {
        font-size: 0.9rem;
      }
      #current-temp {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Current Temperature (TAWES Stations)</h1>

  <div class="controls" role="region" aria-label="Station and time range selection">
    <div class="control-group">
      <label for="station-select">Station:</label>
      <select id="station-select"></select>
    </div>
    <div class="control-group">
      <label for="timerange-select">Past Range:</label>
      <select id="timerange-select" aria-label="Select time range">
        <option value="1">Past 1 hour</option>
        <option value="12">Past 12 hours</option>
        <option value="24" selected>Past 24 hours</option>
        <option value="72">Past 3 days</option>
        <option value="168">Past 7 days</option>
      </select>
    </div>
    <div class="control-group">
      <label for="futuredays-select">Forecast Range:</label>
      <select id="futuredays-select" aria-label="Select forecast days ahead">
        <option value="1" selected>1 day ahead</option>
        <option value="2">2 days ahead</option>
        <option value="3">3 days ahead</option>
        <option value="7">7 days ahead</option>
      </select>
    </div>
    <div class="control-group">
      <label for="corsproxy-input">CORS Proxy:</label>
      <input type="text" id="corsproxy-input" aria-label="Enter CORS proxy URL" placeholder="Enter CORS proxy URL">
    </div>
    <button id="location-btn" title="Find nearest station to your current location">Use My Location</button>
  </div>

  <canvas id="tempChart" width="900" height="400" aria-label="Temperature chart"></canvas>
  <div id="current-temp" aria-live="polite" aria-atomic="true"></div>
  <div id="last-updated"></div>
  <div id="error-msg" role="alert" aria-live="assertive"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0/dist/chartjs-plugin-annotation.min.js"></script>
  <script>
const stationSelect = document.getElementById('station-select');
const locationBtn = document.getElementById('location-btn');
const errorMsg = document.getElementById('error-msg');
const ctx = document.getElementById('tempChart').getContext('2d');
const lastUpdatedDiv = document.getElementById('last-updated');
const timerangeSelect = document.getElementById('timerange-select');
const currentTempDiv = document.getElementById('current-temp');
const futuredaysSelect = document.getElementById('futuredays-select');
const corsproxyInput = document.getElementById('corsproxy-input');

let stations = {};
let forecastPoints = [];
let tempChart;
let refreshIntervalId;

const STORAGE_KEY_STATION = 'selectedStationId';
const STORAGE_KEY_TIMERANGE = 'selectedTimeRangeHours';
const STORAGE_KEY_FUTUREDAYS = 'selectedFutureDays';
const STORAGE_KEY_CORSPROXY = 'selectedCorsProxy';

function toISOStringNoMs(date) {
  return date.toISOString().split('.')[0] + 'Z';
}

function haversineDistance(lat1, lon1, lat2, lon2) {
  const toRad = angle => angle * Math.PI / 180;
  const R = 6371000;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function applyCorsProxy(url) {
  const proxy = corsproxyInput.value.trim() || '';
  if (!proxy) return url;
  // Add trailing slash if missing
  const proxyNormalized = proxy.endsWith('/') ? proxy : proxy + '/';
  if (url.startsWith(proxyNormalized)) return url;
  // Remove leading slash from url if present to avoid double slash
  const urlNormalized = url.startsWith('/') ? url.slice(1) : url;
  return proxyNormalized + urlNormalized;
}

async function fetchWithProxy(url) {
  const proxiedUrl = applyCorsProxy(url);
  const response = await fetch(proxiedUrl);
  if (!response.ok) throw new Error(`HTTP ${response.status} fetching ${url}`);
  return response.json();
}

async function loadForecastPoints() {
  try {
    forecastPoints = await fetchWithProxy('https://www.geosphere.at/data/forecasts/points');
  } catch (err) {
    forecastPoints = [];
    throw err;
  }
}

async function loadStations() {
    const savedCorsProxy = localStorage.getItem(STORAGE_KEY_CORSPROXY);

    // Set CORS proxy input value first, with default if no saved value
    if (savedCorsProxy !== null && savedCorsProxy.trim() !== '') {
      corsproxyInput.value = savedCorsProxy.trim();
    } else {
      corsproxyInput.value = 'https://cors-anywhere.herokuapp.com/';
    }
    
  errorMsg.textContent = '';
  try {
    await loadForecastPoints();
    const metaData = await fetchWithProxy('https://www.geosphere.at/data/stations/tawes/points');
    if (!metaData.mapping) throw new Error('Invalid station metadata format');

    const coordData = await fetchWithProxy('https://www.geosphere.at/data/stations/tawes/current_data');
    if (!coordData.features) throw new Error('Invalid station coordinates format');

    const coordsMap = {};
    for (const feature of coordData.features) {
      const sid = String(feature.properties.station);
      const coords = feature.geometry.coordinates;
      coordsMap[sid] = { lat: coords[1], lon: coords[0] };
    }

    stations = {};
    for (const [stationId, info] of Object.entries(metaData.mapping)) {
      stations[stationId] = {
        name: info.name,
        klima_id: info.klima_id,
        elevation: info.elevation,
        lat: coordsMap[stationId]?.lat ?? null,
        lon: coordsMap[stationId]?.lon ?? null,
        point_id: info.klima_id || stationId
      };
    }

    stationSelect.innerHTML = '';
    const sortedStations = Object.entries(stations)
      .filter(([, s]) => s.lat !== null && s.lon !== null)
      .sort((a, b) => a[1].name.localeCompare(b[1].name));

    for (const [stationId, info] of sortedStations) {
      const option = document.createElement('option');
      option.value = stationId;
      option.textContent = capitalizeWords(info.name);
      stationSelect.appendChild(option);
    }

    // Load saved values
    const savedStationId = localStorage.getItem(STORAGE_KEY_STATION);
    const savedTimeRange = localStorage.getItem(STORAGE_KEY_TIMERANGE);
    const savedFutureDays = localStorage.getItem(STORAGE_KEY_FUTUREDAYS);

    // Validate and set time range and future days selects
    if (savedTimeRange && timerangeSelect.querySelector(`option[value="${savedTimeRange}"]`)) {
      timerangeSelect.value = savedTimeRange;
    }
    if (savedFutureDays && futuredaysSelect.querySelector(`option[value="${savedFutureDays}"]`)) {
      futuredaysSelect.value = savedFutureDays;
    }

    // Set station select and start loading data
    if (savedStationId && stations[savedStationId]) {
      stationSelect.value = savedStationId;
      startRefresh(savedStationId, parseInt(timerangeSelect.value), parseInt(futuredaysSelect.value));
    } else if (stationSelect.options.length > 0) {
      stationSelect.selectedIndex = 0;
      startRefresh(stationSelect.value, parseInt(timerangeSelect.value), parseInt(futuredaysSelect.value));
    }
  } catch (error) {
    lastUpdatedDiv.textContent = '';
    errorMsg.textContent = `Error loading stations: ${error.message}`;
  }
}

function capitalizeWords(str) {
  return str.toLowerCase().split(/\s+/).map(word => {
    if (word.length === 0) return '';
    return word[0].toUpperCase() + word.slice(1);
  }).join(' ');
}


function findNearestForecastPoint(lat, lon) {
  if (forecastPoints.length === 0 || lat === null || lon === null) return null;
  let minDist = Infinity;
  let nearestPointId = null;
  for (const pt of forecastPoints) {
    const dist = haversineDistance(lat, lon, pt.lat, pt.lon);
    if (dist < minDist) {
      minDist = dist;
      nearestPointId = pt.point_id;
    }
  }
  return nearestPointId;
}

async function fetchFlexiForecastForStation(lat, lon) {
  const pointId = findNearestForecastPoint(lat, lon);
  if (!pointId) return null;
  const url = `https://www.geosphere.at/data/forecasts/flexi/${pointId}`;
  const data = await fetchWithProxy(url);
  if (!data.timestamps || !data.features || data.features.length === 0) throw new Error('Invalid forecast data format.');
  const feature = data.features[0];
  const timestamps = data.timestamps.map(ts => new Date(ts));
  const params = feature.properties.parameters;
  const t2m = params.t2m?.data ?? [];
  return { timestamps, t2m };
}

async function fetchAndUpdateData(stationId, hoursRange, futureDays) {
  try {
    errorMsg.textContent = '';
    const now = new Date();
    const startDate = new Date(now.getTime() - hoursRange * 3600 * 1000);
    const endDate = now;
    const url = new URL('https://dataset.api.hub.geosphere.at/v1/station/historical/tawes-v1-10min');
    url.searchParams.set('parameters', 'TL');
    url.searchParams.set('start', toISOStringNoMs(startDate));
    url.searchParams.set('end', toISOStringNoMs(endDate));
    url.searchParams.set('station_ids', stationId);
    lastUpdatedDiv.textContent = 'Loading data...';
    const data = await fetchWithProxy(url.toString());
    if (!data.features || data.features.length === 0) throw new Error('No data available for this station.');
    const timestamps = data.timestamps.map(ts => new Date(ts));
    const TL = data.features[0].properties.parameters.TL?.data ?? [];
    const lat = stations[stationId]?.lat;
    const lon = stations[stationId]?.lon;
    const forecast = await fetchFlexiForecastForStation(lat, lon);
    let combinedLabels = timestamps.map(ts => hoursRange > 24 ? ts.toLocaleString([], {year:'2-digit', month:'2-digit', day:'2-digit', hour12:false, hour: '2-digit', minute:'2-digit'}) : ts.toLocaleTimeString([], {hour12: false, hour: '2-digit', minute:'2-digit'}));
    let forecastLabels = [];
    let forecastTemps = [];
    if (forecast) {
      const maxFutureDate = new Date(now.getTime() + futureDays * 24 * 3600 * 1000);
      const filteredForecastIndices = [];
      for (let i = 0; i < forecast.timestamps.length; i++) {
        const ts = forecast.timestamps[i];
        if (ts > now && ts <= maxFutureDate) filteredForecastIndices.push(i);
      }
      forecastLabels = filteredForecastIndices.map(i => forecast.timestamps[i].toLocaleString([], {hour12:false, hour:'2-digit', minute:'2-digit', day:'2-digit', month:'2-digit'}));
      forecastTemps = filteredForecastIndices.map(i => forecast.t2m[i]);
    }
    const lastValidPastIndex = TL.slice().reverse().findIndex(val => val !== null && val !== undefined);
    const pastTempsCleaned = lastValidPastIndex >= 0 ? TL.slice(0, TL.length - lastValidPastIndex) : [];
    const firstValidForecastIdx = forecastTemps.findIndex(val => val !== null && val !== undefined);
    const forecastTempsCleaned = firstValidForecastIdx >= 0 ? forecastTemps.slice(firstValidForecastIdx) : [];
    const forecastLabelsCleaned = firstValidForecastIdx >= 0 ? forecastLabels.slice(firstValidForecastIdx) : [];
    const combinedTemps = [...pastTempsCleaned, ...forecastTempsCleaned];
    const combinedLabelsAdjusted = [...timestamps.slice(0, pastTempsCleaned.length).map(ts => hoursRange > 24 ? ts.toLocaleString([], {year:'2-digit', month:'2-digit', day:'2-digit', hour12:false, hour: '2-digit', minute:'2-digit'}) : ts.toLocaleTimeString([], {hour12: false, hour: '2-digit', minute:'2-digit'})), ...forecastLabelsCleaned];
    if (tempChart) tempChart.destroy();
    tempChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: combinedLabelsAdjusted,
        datasets: [{
          label: `Mean Temp (째C) - ${stations[stationId].name}`,
          data: combinedTemps,
          borderColor: 'rgba(255, 99, 132, 0.8)',
          backgroundColor: 'rgba(255, 99, 132, 0.2)',
          fill: false,
          tension: 0.3,
          pointRadius: 3,
          pointHoverRadius: 6,
          borderWidth: 2,
          spanGaps: true,
        }]
      },
      options: {
        responsive: true,
        animation: false,
        maintainAspectRatio: false,
        scales: {
          x: { title: { display: true, text: 'Time' }, ticks: { maxRotation: 45, minRotation: 30 }, type: 'category' },
          y: { title: { display: true, text: 'Temperature (째C)' }, suggestedMin: 0, suggestedMax: 40 }
        },
        plugins: {
          legend: { display: true },
          tooltip: { mode: 'index', intersect: false, callbacks: { label: ctx => `Temp: ${ctx.parsed.y} 째C` } },
          annotation: {
            annotations: {
              forecastBox: {
                type: 'box',
                xMin: pastTempsCleaned.length,
                xMax: combinedLabelsAdjusted.length - 1,
                backgroundColor: 'rgba(200, 200, 255, 0.15)',
                borderWidth: 0,
              }
            }
          }
        },
        interaction: { mode: 'nearest', intersect: false }
      },
      plugins: [Chart.registry.getPlugin('annotation')].filter(Boolean)
    });
    const lastValidTempIndex = pastTempsCleaned.length - 1;
    const latestTemp = pastTempsCleaned[lastValidTempIndex];
    const latestTime = combinedLabelsAdjusted[lastValidTempIndex];
    currentTempDiv.textContent = latestTemp !== null && latestTemp !== undefined ? `Temperature: ${latestTemp} 째C (at ${latestTime})` : 'No temperature data available.';
    lastUpdatedDiv.textContent = `Last updated: ${new Date().toLocaleString()}`;
  } catch (error) {
    lastUpdatedDiv.textContent = '';
    currentTempDiv.textContent = '';
    errorMsg.textContent = `Error loading data: ${error.message}`;
  }
}

function startRefresh(stationId, hoursRange, futureDays) {
  if (refreshIntervalId) clearInterval(refreshIntervalId);
  fetchAndUpdateData(stationId, hoursRange, futureDays);
  refreshIntervalId = setInterval(() => fetchAndUpdateData(stationId, hoursRange, futureDays), 300000);
}

stationSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureDays = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_STATION, selectedStation);
    startRefresh(selectedStation, selectedRange, selectedFutureDays);
  }
});

timerangeSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureDays = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_TIMERANGE, selectedRange);
    startRefresh(selectedStation, selectedRange, selectedFutureDays);
  }
});

futuredaysSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureDays = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_FUTUREDAYS, selectedFutureDays);
    startRefresh(selectedStation, selectedRange, selectedFutureDays);
  }
});

// Use 'input' event to listen for character changes in the CORS proxy input
corsproxyInput.addEventListener('input', () => {
  const selectedProxy = corsproxyInput.value.trim();
  localStorage.setItem(STORAGE_KEY_CORSPROXY, selectedProxy);
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureDays = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    startRefresh(selectedStation, selectedRange, selectedFutureDays);
  }
});

locationBtn.addEventListener('click', () => {
  errorMsg.textContent = '';
  if (!navigator.geolocation) {
    errorMsg.textContent = 'Geolocation is not supported by your browser.';
    return;
  }
  locationBtn.disabled = true;
  locationBtn.textContent = 'Locating...';
  navigator.geolocation.getCurrentPosition(position => {
    const userLat = position.coords.latitude;
    const userLon = position.coords.longitude;
    let minDist = Infinity;
    let nearestStationId = null;
    for (const [stationId, info] of Object.entries(stations)) {
      if (info.lat === null || info.lon === null) continue;
      const dist = haversineDistance(userLat, userLon, info.lat, info.lon);
      if (dist < minDist) {
        minDist = dist;
        nearestStationId = stationId;
      }
    }
    if (nearestStationId) {
      stationSelect.value = nearestStationId;
      localStorage.setItem(STORAGE_KEY_STATION, nearestStationId);
      const selectedRange = parseInt(timerangeSelect.value);
      const selectedFutureDays = parseInt(futuredaysSelect.value);
      startRefresh(nearestStationId, selectedRange, selectedFutureDays);
      errorMsg.textContent = `Nearest station selected: ${stations[nearestStationId].name}`;
    } else {
      errorMsg.textContent = 'Could not find a nearby station.';
    }
    locationBtn.disabled = false;
    locationBtn.textContent = 'Use My Location';
  }, err => {
    errorMsg.textContent = `Geolocation error: ${err.message}`;
    locationBtn.disabled = false;
    locationBtn.textContent = 'Use My Location';
  }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 });
});

loadStations();
  </script>
</body>
</html>
