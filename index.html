<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Temperature Chart - TAWES Stations with fallback & responsive</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 1rem auto;
      padding: 0 1rem;
      background: #f7f9fc;
      color: #333;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }
    .controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }
    label {
      font-weight: bold;
      margin-right: 0.5rem;
      white-space: nowrap;
    }
    select {
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
      min-width: 180px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    #location-btn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: #007bff;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
    }
    #location-btn:hover:not(:disabled) {
      background-color: #0056b3;
    }
    #location-btn:disabled {
      background-color: #999;
      cursor: default;
    }
    #last-updated {
      margin-top: 0.5rem;
      font-style: italic;
      color: #555;
      text-align: center;
      font-size: 0.9rem;
    }
    #error-msg {
      color: #cc0000;
      font-weight: bold;
      margin-top: 0.5rem;
      text-align: center;
      min-height: 1.2em;
      font-size: 0.95rem;
    }
    canvas {
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      max-width: 100%;
      height: auto !important;
      display: block;
      margin: 0 auto;
    }

    /* Responsive tweaks */
    @media (max-width: 480px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
        gap: 0.75rem;
      }
      label {
        margin-right: 0;
        text-align: center;
        font-size: 1.1rem;
      }
      select, #location-btn {
        width: 100%;
        min-width: auto;
        font-size: 1.1rem;
        padding: 0.6rem;
      }
      h1 {
        font-size: 1.3rem;
        margin-bottom: 1rem;
      }
      #last-updated {
        font-size: 0.85rem;
      }
      #error-msg {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <h1>Current Temperature (TAWES Stations)</h1>

  <div class="controls">
    <label for="station-select">Select Station:</label>
    <select id="station-select"></select>
    <button id="location-btn" title="Find nearest station to your current location">Use My Location</button>

    <label for="timerange-select">Select Time Range:</label>
    <select id="timerange-select" aria-label="Select time range">
      <option value="1">Past 1 hour</option>
      <option value="12">Past 12 hours</option>
      <option value="24" selected>Past 24 hours</option>
      <option value="72">Past 3 days</option>
      <option value="168">Past 7 days</option>
    </select>
  </div>

  <canvas id="tempChart" width="800" height="400"></canvas>
  <div id="last-updated"></div>
  <div id="error-msg" role="alert" aria-live="assertive"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const stationSelect = document.getElementById('station-select');
    const locationBtn = document.getElementById('location-btn');
    const errorMsg = document.getElementById('error-msg');
    const ctx = document.getElementById('tempChart').getContext('2d');
    const lastUpdatedDiv = document.getElementById('last-updated');
    const timerangeSelect = document.getElementById('timerange-select');

    let stations = {}; // merged station info keyed by stationId
    let tempChart;
    let refreshIntervalId;

    const STORAGE_KEY_STATION = 'selectedStationId';
    const STORAGE_KEY_TIMERANGE = 'selectedTimeRangeHours';

    function toISOStringNoMs(date) {
      return date.toISOString().split('.')[0] + 'Z';
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const toRad = angle => angle * Math.PI / 180;
      const R = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // Try fetch JSON from URL, fallback to local file URL on error
    async function fetchWithFallback(remoteUrl, localUrl) {
      try {
        const response = await fetch(remoteUrl);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
      } catch (err) {
        console.warn(`Failed to fetch ${remoteUrl}, falling back to ${localUrl}:`, err);
        // try local file
        const response = await fetch(localUrl);
        if (!response.ok) throw new Error(`Fallback HTTP ${response.status}`);
        return await response.json();
      }
    }

    async function loadStations() {
      errorMsg.textContent = '';
      try {
        // Fetch metadata with fallback
        const metaData = await fetchWithFallback(
          'https://www.geosphere.at/data/stations/tawes/points',
          './points.json'
        );
        if (!metaData.mapping) throw new Error('Invalid station metadata format');

        // Fetch coordinates with fallback
        const coordData = await fetchWithFallback(
          'https://www.geosphere.at/data/stations/tawes/current_data',
          './current_data.json'
        );
        if (!coordData.features) throw new Error('Invalid station coordinates format');

        // Build coords map
        const coordsMap = {};
        for (const feature of coordData.features) {
          const sid = String(feature.properties.station);
          const coords = feature.geometry.coordinates;
          coordsMap[sid] = { lat: coords[1], lon: coords[0] };
        }

        // Merge metadata + coords
        stations = {};
        for (const [stationId, info] of Object.entries(metaData.mapping)) {
          stations[stationId] = {
            name: info.name,
            klima_id: info.klima_id,
            elevation: info.elevation,
            lat: coordsMap[stationId]?.lat ?? null,
            lon: coordsMap[stationId]?.lon ?? null
          };
        }

        // Populate dropdown (only stations with coords)
        stationSelect.innerHTML = '';
        const sortedStations = Object.entries(stations)
          .filter(([, s]) => s.lat !== null && s.lon !== null)
          .sort((a, b) => a[1].name.localeCompare(b[1].name));

        for (const [stationId, info] of sortedStations) {
          const option = document.createElement('option');
          option.value = stationId;
          option.textContent = `${info.name} (ID: ${stationId})`;
          stationSelect.appendChild(option);
        }

        // Restore saved station or select first
        const savedStationId = localStorage.getItem(STORAGE_KEY_STATION);
        const savedTimeRange = localStorage.getItem(STORAGE_KEY_TIMERANGE);

        if (savedTimeRange && timerangeSelect.querySelector(`option[value="${savedTimeRange}"]`)) {
          timerangeSelect.value = savedTimeRange;
        }

        if (savedStationId && stations[savedStationId]) {
          stationSelect.value = savedStationId;
          startRefresh(savedStationId, parseInt(timerangeSelect.value));
        } else if (stationSelect.options.length > 0) {
          stationSelect.selectedIndex = 0;
          startRefresh(stationSelect.value, parseInt(timerangeSelect.value));
        }

      } catch (error) {
        lastUpdatedDiv.textContent = '';
        errorMsg.textContent = `Error loading stations: ${error.message}`;
        console.error(error);
      }
    }

    async function fetchAndUpdateData(stationId, hoursRange) {
      try {
        errorMsg.textContent = '';
        const now = new Date();

        // Calculate start date based on selected range in hours
        const startDate = new Date(now.getTime() - hoursRange * 3600 * 1000);
        // Sometimes datasets need UTC start aligned, but here we just use exact date/time

        // End date slightly in future to include latest data
        const endDate = new Date(now.getTime() + 10 * 60000);

        const url = new URL('https://dataset.api.hub.geosphere.at/v1/station/historical/tawes-v1-10min');
        url.searchParams.set('parameters', 'TL');
        url.searchParams.set('start', toISOStringNoMs(startDate));
        url.searchParams.set('end', toISOStringNoMs(endDate));
        url.searchParams.set('station_ids', stationId);

        lastUpdatedDiv.textContent = 'Loading data...';

        const response = await fetch(url.toString());
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();

        if (!data.features || data.features.length === 0) {
          throw new Error('No data available for this station.');
        }

        const timestamps = data.timestamps.map(ts => new Date(ts));
        const temperatureData = data.features[0].properties.parameters.TL.data;

        // Format labels based on selected range: show date+time if > 24h else only time
        const labels = timestamps.map(ts => {
          if (hoursRange > 24) {
            return ts.toLocaleString([], {year:'2-digit', month:'2-digit', day:'2-digit', hour12:false, hour: '2-digit', minute:'2-digit'});
          } else {
            return ts.toLocaleTimeString([], {hour12: false, hour: '2-digit', minute:'2-digit'});
          }
        });
        const temps = temperatureData;

        if (tempChart) {
          tempChart.data.labels = labels;
          tempChart.data.datasets[0].data = temps;
          tempChart.data.datasets[0].label = `Temperature (째C) - ${stations[stationId].name}`;
          tempChart.update();
        } else {
          tempChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [{
                label: `Temperature (째C) - ${stations[stationId].name}`,
                data: temps,
                borderColor: 'rgba(255, 99, 132, 0.8)',
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                fill: true,
                tension: 0.3,
                pointRadius: 3,
                pointHoverRadius: 6,
                borderWidth: 2,
              }]
            },
            options: {
              responsive: true,
              animation: false,
              scales: {
                x: {
                  title: { display: true, text: 'Time (UTC)' },
                  ticks: { maxRotation: 45, minRotation: 30 }
                },
                y: {
                  title: { display: true, text: 'Temperature (째C)' },
                  suggestedMin: 0,
                  suggestedMax: 40
                }
              },
              plugins: {
                legend: { display: true },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                  callbacks: {
                    label: ctx => `${ctx.parsed.y} 째C`
                  }
                }
              },
              interaction: {
                mode: 'nearest',
                intersect: false
              }
            }
          });
        }

        lastUpdatedDiv.textContent = `Last updated: ${new Date().toLocaleString()}`;

      } catch (error) {
        lastUpdatedDiv.textContent = '';
        errorMsg.textContent = `Error loading data: ${error.message}`;
        console.error(error);
      }
    }

    function startRefresh(stationId, hoursRange) {
      if (refreshIntervalId) clearInterval(refreshIntervalId);

      fetchAndUpdateData(stationId, hoursRange);

      refreshIntervalId = setInterval(() => {
        fetchAndUpdateData(stationId, hoursRange);
      }, 300000);
    }

    stationSelect.addEventListener('change', () => {
      const selectedStation = stationSelect.value;
      const selectedRange = parseInt(timerangeSelect.value);
      if (selectedStation) {
        localStorage.setItem(STORAGE_KEY_STATION, selectedStation);
        startRefresh(selectedStation, selectedRange);
      }
    });

    timerangeSelect.addEventListener('change', () => {
      const selectedStation = stationSelect.value;
      const selectedRange = parseInt(timerangeSelect.value);
      if (selectedStation) {
        localStorage.setItem(STORAGE_KEY_TIMERANGE, selectedRange);
        startRefresh(selectedStation, selectedRange);
      }
    });

    locationBtn.addEventListener('click', () => {
      errorMsg.textContent = '';
      if (!navigator.geolocation) {
        errorMsg.textContent = 'Geolocation is not supported by your browser.';
        return;
      }

      locationBtn.disabled = true;
      locationBtn.textContent = 'Locating...';

      navigator.geolocation.getCurrentPosition(position => {
        const userLat = position.coords.latitude;
        const userLon = position.coords.longitude;

        let minDist = Infinity;
        let nearestStationId = null;

        for (const [stationId, info] of Object.entries(stations)) {
          if (info.lat === null || info.lon === null) continue;
          const dist = haversineDistance(userLat, userLon, info.lat, info.lon);
          if (dist < minDist) {
            minDist = dist;
            nearestStationId = stationId;
          }
        }

        if (nearestStationId) {
          stationSelect.value = nearestStationId;
          localStorage.setItem(STORAGE_KEY_STATION, nearestStationId);
          // Also start refresh with current time range
          const selectedRange = parseInt(timerangeSelect.value);
          startRefresh(nearestStationId, selectedRange);
          errorMsg.textContent = `Nearest station selected: ${stations[nearestStationId].name}`;
        } else {
          errorMsg.textContent = 'Could not find a nearby station.';
        }

        locationBtn.disabled = false;
        locationBtn.textContent = 'Use My Location';

      }, err => {
        errorMsg.textContent = `Geolocation error: ${err.message}`;
        locationBtn.disabled = false;
        locationBtn.textContent = 'Use My Location';
      }, {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 60000
      });
    });

    loadStations();
  </script>
</body>
</html>
