<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Temperature Chart - TAWES Stations with fallback & responsive</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0 1rem;
      background: #f7f9fc;
      color: #333;
      max-width: none;
      width: 100vw;
      box-sizing: border-box;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }
    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    .control-group {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0.3rem;
      white-space: nowrap;
    }
    label {
      font-weight: bold;
      flex-shrink: 0;
    }
    select {
      padding: 0.4rem 0.6rem;
      font-size: 1rem;
      min-width: 140px;
      border-radius: 4px;
      border: 1px solid #ccc;
      flex-shrink: 0;
    }
    #location-btn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: #007bff;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      white-space: nowrap;
      flex-shrink: 0;
      align-self: center;
    }
    #location-btn:hover:not(:disabled) {
      background-color: #0056b3;
    }
    #location-btn:disabled {
      background-color: #999;
      cursor: default;
    }
    #last-updated {
      margin-top: 0.5rem;
      font-style: italic;
      color: #555;
      text-align: center;
      font-size: 0.9rem;
    }
    #error-msg {
      color: #cc0000;
      font-weight: bold;
      margin-top: 0.5rem;
      text-align: center;
      min-height: 1.2em;
      font-size: 0.95rem;
    }
    #current-temp {
      text-align: center;
      font-weight: bold;
      margin-top: 0.5rem;
      font-size: 1.1rem;
    }
    canvas {
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      width: 100%;
      height: 670px !important;
      max-height: 50%;
      display: block;
      margin: 0 auto;
      object-fit: contain;
    }
    @media (max-width: 480px) {
      .controls {
        gap: 0.75rem;
        justify-content: center;
      }
      .control-group {
        gap: 0.25rem;
      }
      label {
        font-size: 1rem;
      }
      select, #location-btn {
        font-size: 1rem;
        min-width: 110px;
        padding: 0.4rem 0.5rem;
      }
      h1 {
        font-size: 1.3rem;
        margin-bottom: 1rem;
      }
      #last-updated {
        font-size: 0.85rem;
      }
      #error-msg {
        font-size: 0.9rem;
      }
      #current-temp {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Current Temperature (TAWES Stations)</h1>

  <div class="controls" role="region" aria-label="Station and time range selection">
    <div class="control-group">
      <label for="station-select">Select Station:</label>
      <select id="station-select"></select>
    </div>
    <div class="control-group">
      <label for="timerange-select">Select Time Range:</label>
      <select id="timerange-select" aria-label="Select time range">
        <option value="1">Past 1 hour</option>
        <option value="12">Past 12 hours</option>
        <option value="24" selected>Past 24 hours</option>
        <option value="72">Past 3 days</option>
        <option value="168">Past 7 days</option>
      </select>
    </div>
    <div class="control-group">
      <label for="futuredays-select">Forecast Days Ahead:</label>
      <select id="futuredays-select" aria-label="Select forecast days ahead">
        <option value="1" selected>1 day ahead</option>
        <option value="2">2 days ahead</option>
        <option value="3">3 days ahead</option>
        <option value="7">7 days ahead</option>
      </select>
    </div>
    <button id="location-btn" title="Find nearest station to your current location">Use My Location</button>
  </div>

  <canvas id="tempChart" width="900" height="400" aria-label="Temperature chart"></canvas>
  <div id="current-temp" aria-live="polite" aria-atomic="true"></div>
  <div id="last-updated"></div>
  <div id="error-msg" role="alert" aria-live="assertive"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0/dist/chartjs-plugin-annotation.min.js"></script>
  <script>
const stationSelect = document.getElementById('station-select');
const locationBtn = document.getElementById('location-btn');
const errorMsg = document.getElementById('error-msg');
const ctx = document.getElementById('tempChart').getContext('2d');
const lastUpdatedDiv = document.getElementById('last-updated');
const timerangeSelect = document.getElementById('timerange-select');
const currentTempDiv = document.getElementById('current-temp');
const futuredaysSelect = document.getElementById('futuredays-select');

let stations = {};
let forecastPoints = [];
let tempChart;
let refreshIntervalId;

const STORAGE_KEY_STATION = 'selectedStationId';
const STORAGE_KEY_TIMERANGE = 'selectedTimeRangeHours';
const STORAGE_KEY_FUTUREDAYS = 'selectedFutureDays';

function toISOStringNoMs(date) {
  return date.toISOString().split('.')[0] + 'Z';
}

function haversineDistance(lat1, lon1, lat2, lon2) {
  const toRad = angle => angle * Math.PI / 180;
  const R = 6371000;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

async function fetchWithFallback(remoteUrl, localUrl) {
  try {
    const response = await fetch(remoteUrl);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return await response.json();
  } catch (err) {
    const response = await fetch(localUrl);
    if (!response.ok) throw new Error(`Fallback HTTP ${response.status}`);
    return await response.json();
  }
}

async function loadForecastPoints() {
  try {
    const response = await fetch('https://www.geosphere.at/data/forecasts/points');
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    forecastPoints = await response.json();
  } catch (err) {
    forecastPoints = [];
  }
}

async function loadStations() {
  errorMsg.textContent = '';
  await loadForecastPoints();
  try {
    const metaData = await fetchWithFallback(
      'https://www.geosphere.at/data/stations/tawes/points',
      './points.json'
    );
    if (!metaData.mapping) throw new Error('Invalid station metadata format');

    const coordData = await fetchWithFallback(
      'https://www.geosphere.at/data/stations/tawes/current_data',
      './current_data.json'
    );
    if (!coordData.features) throw new Error('Invalid station coordinates format');

    const coordsMap = {};
    for (const feature of coordData.features) {
      const sid = String(feature.properties.station);
      const coords = feature.geometry.coordinates;
      coordsMap[sid] = { lat: coords[1], lon: coords[0] };
    }

    stations = {};
    for (const [stationId, info] of Object.entries(metaData.mapping)) {
      stations[stationId] = {
        name: info.name,
        klima_id: info.klima_id,
        elevation: info.elevation,
        lat: coordsMap[stationId]?.lat ?? null,
        lon: coordsMap[stationId]?.lon ?? null,
        point_id: info.klima_id || stationId
      };
    }

    stationSelect.innerHTML = '';
    const sortedStations = Object.entries(stations)
      .filter(([, s]) => s.lat !== null && s.lon !== null)
      .sort((a, b) => a[1].name.localeCompare(b[1].name));

    for (const [stationId, info] of sortedStations) {
      const option = document.createElement('option');
      option.value = stationId;
      option.textContent = `${info.name} (ID: ${stationId})`;
      stationSelect.appendChild(option);
    }

    const savedStationId = localStorage.getItem(STORAGE_KEY_STATION);
    const savedTimeRange = localStorage.getItem(STORAGE_KEY_TIMERANGE);
    const savedFutureDays = localStorage.getItem(STORAGE_KEY_FUTUREDAYS);

    if (savedTimeRange && timerangeSelect.querySelector(`option[value="${savedTimeRange}"]`)) {
      timerangeSelect.value = savedTimeRange;
    }

    if (savedFutureDays && futuredaysSelect.querySelector(`option[value="${savedFutureDays}"]`)) {
      futuredaysSelect.value = savedFutureDays;
    }

    if (savedStationId && stations[savedStationId]) {
      stationSelect.value = savedStationId;
      startRefresh(savedStationId, parseInt(timerangeSelect.value), parseInt(futuredaysSelect.value));
    } else if (stationSelect.options.length > 0) {
      stationSelect.selectedIndex = 0;
      startRefresh(stationSelect.value, parseInt(timerangeSelect.value), parseInt(futuredaysSelect.value));
    }
  } catch (error) {
    lastUpdatedDiv.textContent = '';
    errorMsg.textContent = `Error loading stations: ${error.message}`;
  }
}

function findNearestForecastPoint(lat, lon) {
  if (forecastPoints.length === 0 || lat === null || lon === null) return null;
  let minDist = Infinity;
  let nearestPointId = null;
  for (const pt of forecastPoints) {
    const dist = haversineDistance(lat, lon, pt.lat, pt.lon);
    if (dist < minDist) {
      minDist = dist;
      nearestPointId = pt.point_id;
    }
  }
  return nearestPointId;
}

async function fetchLocalForecastFallback(pointId) {
  try {
    const response = await fetch('./points_forecast.json');
    if (!response.ok) throw new Error(`Fallback forecast HTTP ${response.status}`);
    const localData = await response.json();

    // localData should be an array or object containing forecast data keyed by point_id
    // Adjust the below depending on your local JSON structure
    // For example, if localData is { [point_id]: { timestamps: [...], t2m: [...] }, ... }

    if (!localData[pointId]) throw new Error('No forecast data for point in local fallback');

    const forecast = localData[pointId];
    // Assuming timestamps are ISO strings, convert to Date
    const timestamps = forecast.timestamps.map(ts => new Date(ts));
    const t2m = forecast.t2m;

    return { timestamps, t2m };
  } catch (err) {
    console.warn('Local forecast fallback failed:', err);
    return null;
  }
}

async function fetchFlexiForecastForStation(lat, lon) {
  const pointId = findNearestForecastPoint(lat, lon);
  if (!pointId) return null;
  try {
    const url = `https://www.geosphere.at/data/forecasts/flexi/${pointId}`;
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    if (!data.timestamps || !data.features || data.features.length === 0) throw new Error('Invalid forecast data format.');
    const feature = data.features[0];
    const timestamps = data.timestamps.map(ts => new Date(ts));
    const params = feature.properties.parameters;
    const t2m = params.t2m?.data ?? [];
    return { timestamps, t2m };
  } catch (err) {
    // Remote forecast failed — try local fallback
    return await fetchLocalForecastFallback(pointId);
  }
}

async function fetchAndUpdateData(stationId, hoursRange, futureDays) {
  try {
    errorMsg.textContent = '';
    const now = new Date();

    const startDate = new Date(now.getTime() - hoursRange * 3600 * 1000);
    const endDate = now;

    const url = new URL('https://dataset.api.hub.geosphere.at/v1/station/historical/tawes-v1-10min');
    url.searchParams.set('parameters', 'TL');
    url.searchParams.set('start', toISOStringNoMs(startDate));
    url.searchParams.set('end', toISOStringNoMs(endDate));
    url.searchParams.set('station_ids', stationId);

    lastUpdatedDiv.textContent = 'Loading data...';

    const response = await fetch(url.toString());
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const data = await response.json();

    if (!data.features || data.features.length === 0) throw new Error('No data available for this station.');

    const timestamps = data.timestamps.map(ts => new Date(ts));
    const TL = data.features[0].properties.parameters.TL?.data ?? [];

    const lat = stations[stationId]?.lat;
    const lon = stations[stationId]?.lon;
    const forecast = await fetchFlexiForecastForStation(lat, lon);

    let combinedLabels = timestamps.map(ts => {
      if (hoursRange > 24) {
        return ts.toLocaleString([], {year:'2-digit', month:'2-digit', day:'2-digit', hour12:false, hour: '2-digit', minute:'2-digit'});
      } else {
        return ts.toLocaleTimeString([], {hour12: false, hour: '2-digit', minute:'2-digit'});
      }
    });

    let forecastLabels = [];
    let forecastTemps = [];

    if (forecast) {
      const maxFutureDate = new Date(now.getTime() + futureDays * 24 * 3600 * 1000);
      const filteredForecastIndices = [];
      for (let i = 0; i < forecast.timestamps.length; i++) {
        const ts = forecast.timestamps[i];
        if (ts > now && ts <= maxFutureDate) {
          filteredForecastIndices.push(i);
        }
      }
      forecastLabels = filteredForecastIndices.map(i =>
        forecast.timestamps[i].toLocaleString([], {hour12:false, hour:'2-digit', minute:'2-digit', day:'2-digit', month:'2-digit'})
      );
      forecastTemps = filteredForecastIndices.map(i => forecast.t2m[i]);
    }

    const lastValidPastIndex = (() => {
      for(let i=TL.length-1; i>=0; i--) {
        if (TL[i] !== null && TL[i] !== undefined) return i;
      }
      return -1;
    })();

    const pastTempsCleaned = lastValidPastIndex >= 0 ? TL.slice(0, lastValidPastIndex + 1) : [];

    const firstValidForecastIdx = (() => {
      for(let i=0; i<forecastTemps.length; i++) {
        if (forecastTemps[i] !== null && forecastTemps[i] !== undefined) return i;
      }
      return -1;
    })();

    const forecastTempsCleaned = firstValidForecastIdx >= 0 ? forecastTemps.slice(firstValidForecastIdx) : [];
    const forecastLabelsCleaned = firstValidForecastIdx >= 0 ? forecastLabels.slice(firstValidForecastIdx) : [];

    const combinedTemps = [...pastTempsCleaned, ...forecastTempsCleaned];

    const combinedLabelsAdjusted = [
      ...timestamps.slice(0, pastTempsCleaned.length).map(ts => {
        if (hoursRange > 24) {
          return ts.toLocaleString([], {year:'2-digit', month:'2-digit', day:'2-digit', hour12:false, hour: '2-digit', minute:'2-digit'});
        } else {
          return ts.toLocaleTimeString([], {hour12: false, hour: '2-digit', minute:'2-digit'});
        }
      }),
      ...forecastLabelsCleaned
    ];

    if (tempChart) tempChart.destroy();

    tempChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: combinedLabelsAdjusted,
        datasets: [
          {
            label: `Mean Temp (°C) - ${stations[stationId].name}`,
            data: combinedTemps,
            borderColor: 'rgba(255, 99, 132, 0.8)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            pointHoverRadius: 6,
            borderWidth: 2,
            spanGaps: true,
          }
        ]
      },
      options: {
        responsive: true,
        animation: false,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: { display: true, text: 'Time' },
            ticks: { maxRotation: 45, minRotation: 30 },
            type: 'category',
          },
          y: {
            title: { display: true, text: 'Temperature (°C)' },
            suggestedMin: 0,
            suggestedMax: 40
          }
        },
        plugins: {
          legend: { display: true },
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              label: ctx => `Temp: ${ctx.parsed.y} °C`
            }
          },
          annotation: {
            annotations: {
              forecastBox: {
                type: 'box',
                xMin: pastTempsCleaned.length,
                xMax: combinedLabelsAdjusted.length - 1,
                backgroundColor: 'rgba(200, 200, 255, 0.15)',
                borderWidth: 0,
              }
            }
          }
        },
        interaction: {
          mode: 'nearest',
          intersect: false
        }
      },
      plugins: [Chart.registry.getPlugin('annotation')].filter(Boolean)
    });

    const lastValidTempIndex = pastTempsCleaned.length - 1;
    const latestTemp = pastTempsCleaned[lastValidTempIndex];
    const latestTime = combinedLabelsAdjusted[lastValidTempIndex];
    if (latestTemp !== null && latestTemp !== undefined) {
      currentTempDiv.textContent = `Temperature: ${latestTemp} °C (at ${latestTime})`;
    } else {
      currentTempDiv.textContent = 'No temperature data available.';
    }

    lastUpdatedDiv.textContent = `Last updated: ${new Date().toLocaleString()}`;

  } catch (error) {
    lastUpdatedDiv.textContent = '';
    currentTempDiv.textContent = '';
    errorMsg.textContent = `Error loading data: ${error.message}`;
  }
}

function startRefresh(stationId, hoursRange, futureDays) {
  if (refreshIntervalId) clearInterval(refreshIntervalId);

  fetchAndUpdateData(stationId, hoursRange, futureDays);

  refreshIntervalId = setInterval(() => {
    fetchAndUpdateData(stationId, hoursRange, futureDays);
  }, 300000);
}

stationSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureDays = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_STATION, selectedStation);
    startRefresh(selectedStation, selectedRange, selectedFutureDays);
  }
});

timerangeSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureDays = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_TIMERANGE, selectedRange);
    startRefresh(selectedStation, selectedRange, selectedFutureDays);
  }
});

futuredaysSelect.addEventListener('change', () => {
  const selectedStation = stationSelect.value;
  const selectedRange = parseInt(timerangeSelect.value);
  const selectedFutureDays = parseInt(futuredaysSelect.value);
  if (selectedStation) {
    localStorage.setItem(STORAGE_KEY_FUTUREDAYS, selectedFutureDays);
    startRefresh(selectedStation, selectedRange, selectedFutureDays);
  }
});

locationBtn.addEventListener('click', () => {
  errorMsg.textContent = '';
  if (!navigator.geolocation) {
    errorMsg.textContent = 'Geolocation is not supported by your browser.';
    return;
  }
  locationBtn.disabled = true;
  locationBtn.textContent = 'Locating...';
  navigator.geolocation.getCurrentPosition(position => {
    const userLat = position.coords.latitude;
    const userLon = position.coords.longitude;
    let minDist = Infinity;
    let nearestStationId = null;
    for (const [stationId, info] of Object.entries(stations)) {
      if (info.lat === null || info.lon === null) continue;
      const dist = haversineDistance(userLat, userLon, info.lat, info.lon);
      if (dist < minDist) {
        minDist = dist;
        nearestStationId = stationId;
      }
    }
    if (nearestStationId) {
      stationSelect.value = nearestStationId;
      localStorage.setItem(STORAGE_KEY_STATION, nearestStationId);
      const selectedRange = parseInt(timerangeSelect.value);
      const selectedFutureDays = parseInt(futuredaysSelect.value);
      startRefresh(nearestStationId, selectedRange, selectedFutureDays);
      errorMsg.textContent = `Nearest station selected: ${stations[nearestStationId].name}`;
    } else {
      errorMsg.textContent = 'Could not find a nearby station.';
    }
    locationBtn.disabled = false;
    locationBtn.textContent = 'Use My Location';
  }, err => {
    errorMsg.textContent = `Geolocation error: ${err.message}`;
    locationBtn.disabled = false;
    locationBtn.textContent = 'Use My Location';
  }, {
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 60000
  });
});

loadStations();
  </script>
</body>
</html>
